<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>なんちゃってレアガチャロールズ</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #controls label, #controls input, #controls button { margin-right: 10px; margin-bottom: 10px; display: inline-block; }
        .error { color: red; font-weight: bold; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; table-layout: fixed; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th:not(.col-no):not(.seed-column), td:not(.col-no):not(.seed-column) { width: 100%; }
        th { background-color: #f2f2f2; text-align: center; vertical-align: middle; position: relative; }
        .highlight { background-color: #ffff99; }
        .gacha-select-header { display: flex; align-items: center; justify-content: center; flex-wrap: wrap; }
        .gacha-select-header span { margin-left: 5px; font-size: 12px; }
        .gacha-select-header select {
            width: 20px; /* 幅を最小に */
            -webkit-appearance: none; /* Safari, Chrome */
            -moz-appearance: none; /* Firefox */
            appearance: none; /* 標準 */
            background: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='%23333' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E") no-repeat right / .8em; /* 矢印アイコン */
            padding-right: 1em; /* アイコンのスペース */
        }
        .gacha-select-header button { font-size: 10px; padding: 2px 4px; margin-left: 4px; }
        .add-gacha-btn { font-size: 12px; font-weight: normal; padding: 2px 6px; margin-left: 15px; }
        #result { margin-top: 20px; border: 1px solid #ccc; padding: 10px; white-space: pre-wrap; font-family: monospace; background-color: #f9f9f9; max-height: 300px; overflow-y: auto; }
        #table-actions { text-align: center; margin-top: 20px; }
        #table-actions button { margin: 0 5px; }

        /* Toggle visibility classes */
        .hidden { display: none; }
        .seed-column { width: 90px; text-align: center; font-size: 10px; color: #555; }
        .col-no { width: 45px; text-align: center; white-space: nowrap; }
    </style>
</head>
<body>
    <h1>なんちゃってGachaRolls（gr）シミュレーター（レアロールズ）</h1>

    <div id="controls">
        <label for="seed">SEED:</label>
        <input type="number" id="seed" value="12345" min="1" max="4294967295" onchange="resetAndGenerateTable()">
        <button onclick="updateSeedFromSim()">SEED更新</button>
        <label for="sim-config">シミュレーション:</label>
        <input type="text" id="sim-config" placeholder="ガチャID-ロール数" onchange="resetAndGenerateTable()">
    </div>

    <div id="rolls-table-container"></div>
    <div id="table-actions">
        <button onclick="addMoreRows(100)">100行追加する</button>
        <button id="toggle-seed-btn" onclick="toggleSeedColumns()">SEEDを表示</button>
        <button id="toggle-result-btn" onclick="toggleResultDisplay()">計算過程を表示</button>
    </div>
    <div id="result"></div>

    <script>
        let gachaMasterData = {};
        const dataFiles = ['data/cats.js', 'data/events.js', 'data/gacha.js'];
        let tableGachaIds = [];
        let currentRolls = 100;
        let showSeedColumns = false;
        let showResultDisplay = false;
        let finalSeedForUpdate = null; // SEED更新ボタン用

        const fallbackCats = [
            {id:31,name:"ネコぼさつ",rarity:3},{id:32,name:"ネコ番長",rarity:3},{id:33,name:"ネコザイル",rarity:3},{id:34,name:"ねこタツ",rarity:3},{id:35,name:"ネコルガ",rarity:4},{id:36,name:"オタネコ",rarity:3},{id:37,name:"ネコスイマー",rarity:3},{id:38,name:"ネコホッピング",rarity:2},{id:39,name:"ネコ車輪",rarity:2},{id:40,name:"ネコリンゴ",rarity:3},{id:41,name:"ネコバスたぶ",rarity:3},{id:42,name:"ネコエステ",rarity:2},{id:43,name:"ネコアイス",rarity:4},{id:44,name:"ネコマシン",rarity:4},{id:45,name:"鬼にゃんま",rarity:4},{id:47,name:"ねこジュラ",rarity:2},{id:48,name:"ねこファイター",rarity:2},{id:49,name:"ねこ海賊",rarity:2},{id:50,name:"ねこ泥棒",rarity:2},{id:51,name:"ねこ僧侶",rarity:2},{id:52,name:"ねこ占い師",rarity:2},{id:53,name:"ネコシャーマン",rarity:2},{id:56,name:"ネコ魔女",rarity:2},{id:57,name:"ネコアーチャー",rarity:2},{id:58,name:"ネコシュバリエ",rarity:4},{id:59,name:"ネコ魔剣士",rarity:2},{id:60,name:"ねこベビー",rarity:4},{id:62,name:"ねこ寿司",rarity:3},{id:76,name:"風神のウィンディ",rarity:4},{id:84,name:"地龍ソドム",rarity:4},{id:85,name:"聖龍メギドラ",rarity:4},{id:107,name:"召し豚のカイ",rarity:4},{id:108,name:"宝杖のカッパーマイン",rarity:4},{id:130,name:"金ネコ",rarity:3},{id:132,name:"ねねこ",rarity:3},{id:136,name:"ツルの恩返し",rarity:4},{id:144,name:"ねこナース",rarity:4},{id:145,name:"にゃんこ城Mini",rarity:3},{id:146,name:"ねこガンマン",rarity:2},{id:147,name:"たけうまねこ",rarity:2},{id:148,name:"ブリキネコ",rarity:2},{id:149,name:"ねこロッカー",rarity:2},{id:150,name:"ねこ人魚",rarity:2},{id:151,name:"窓辺の乙女ネコ",rarity:3},{id:152,name:"ネコバーベル",rarity:3},{id:153,name:"ネコスケート",rarity:3},{id:154,name:"ネコトースター",rarity:3},{id:169,name:"アシルガ",rarity:4},{id:170,name:"クビルガ",rarity:4},{id:171,name:"テコルガ",rarity:4},{id:172,name:"バララガ",rarity:4},{id:197,name:"キャットマンダディ",rarity:4},{id:198,name:"サイキックネコ",rarity:2},{id:199,name:"ねこ陰陽師",rarity:2},{id:200,name:"ネコサーファー",rarity:3},{id:201,name:"メタルネコ",rarity:3},{id:238,name:"おかめはちもくネコ",rarity:3},{id:239,name:"ボンボンネコ",rarity:3},{id:240,name:"見習いスニャイパー",rarity:3},{id:241,name:"トゲルガ",rarity:4},{id:258,name:"天空神ゼウス",rarity:4},{id:259,name:"守護神アヌビス",rarity:4},{id:260,name:"美女神アフロディーテ",rarity:4},{id:272,name:"太陽神アマテラス",rarity:4},{id:273,name:"繁栄神ガネーシャ",rarity:4},{id:287,name:"閃雷機兵レイ",rarity:4},{id:308,name:"ネコジャンパー",rarity:3},{id:309,name:"ネコバサミ",rarity:2},{id:317,name:"海王神ポセイドン",rarity:4},{id:326,name:"ネコボクサー",rarity:2},{id:377,name:"ネコ探査機",rarity:2},{id:378,name:"ネコフェンシング",rarity:3},{id:440,name:"時空神クロノス",rarity:4},{id:444,name:"ネコ医師",rarity:2},{id:445,name:"ネコ占い師",rarity:2},{id:446,name:"ネコシャーマン",rarity:2},{id:447,name:"ネコ魔女",rarity:2},{id:448,name:"ネコアーチャー",rarity:2},{id:494,name:"竜騎士バルス",rarity:4},{id:496,name:"ネコパーフェクト",rarity:3},{id:523,name:"ネコ武闘家",rarity:2},{id:524,name:"ネコ法師",rarity:2},{id:535,name:"竜戦機ライデン",rarity:4},{id:643,name:"神龍かむくら",rarity:4},{id:724,name:"聖龍メギドラ",rarity:4},{id:812,name:"地龍ソドム",rarity:4}
        ];
        const fallbackEvents = [
            {id:992,name:"波動バスターズ",rare:7000,supa:2500,uber:500},
            {id:452,name:"エアバスターズ",rare:7000,supa:2500,uber:500},
            {id:523,name:"ギガントゼウス",rare:7000,supa:2500,uber:500}
        ];
        const fallbackGacha = [
            {id:992,cats:[812,724,643,535,494,440,317,273,272,260,259,258,448,447,446,445,444,201,145,132,130,238,239,240,524,523,496,378,377,326,308,309,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]},
            {id:452,cats:[524,523,496,378,377,326,308,309,287,197,144,136,108,107,85,84,76,60,240,239,238,201,145,132,130,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]},
            {id:523,cats:[524,523,496,378,377,326,308,309,287,197,144,136,108,107,85,84,76,60,240,239,238,201,145,132,130,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]}
        ];

        async function loadAndProcessData() {
            const loadedData = {};
            try {
                for (const file of dataFiles) {
                    const response = await fetch(file);
                    if (!response.ok) throw new Error('Network response was not ok.');
                    const text = await response.text();
                    const jsonStr = text.substring(text.indexOf('['), text.lastIndexOf(']') + 1);
                    loadedData[file.split('/')[1].split('.')[0]] = JSON.parse(jsonStr);
                }
            } catch (e) {
                console.warn("Failed to load external data, using fallback data.", e);
                loadedData.cats = fallbackCats;
                loadedData.events = fallbackEvents;
                loadedData.gacha = fallbackGacha;
            }

            const rarityMap = { 0: "nomal", 1: "ex", 2: "rare", 3: "super", 4: "uber", 5: "legend" };
            const catsMaster = {};
            for (const cat of loadedData.cats) { catsMaster[cat.id] = { ...cat, rarity: rarityMap[cat.rarity] || "rare" }; }
            const eventsMaster = {};
            for (const event of loadedData.events) { eventsMaster[event.id] = event; }
            const gachasMaster = {};
            for (const gacha of loadedData.gacha) {
                const eventInfo = eventsMaster[gacha.id];
                if (!eventInfo) continue;
                const pool = { rare: [], super: [], uber: [], legend: [], nomal: [], ex: [] };
                if (gacha.cats) {
                    for (const catId of gacha.cats) {
                        const catInfo = catsMaster[catId];
                        if (catInfo && pool[catInfo.rarity] !== undefined) pool[catInfo.rarity].push({ id: catInfo.id, name: catInfo.name });
                    }
                }
                gachasMaster[gacha.id] = {
                    id: gacha.id.toString(),
                    name: eventInfo.name || gacha.name || `ガチャID: ${gacha.id}`,
                    rarity_rates: { rare: eventInfo.rare || 0, super: eventInfo.supa || 0, uber: eventInfo.uber || 0, legend: eventInfo.legend || 0 },
                    pool: pool
                };
            }
            gachaMasterData = { cats: catsMaster, gachas: gachasMaster };

            const urlParams = new URLSearchParams(window.location.search);
            const seedParam = urlParams.get('seed');
            const simConfigParam = urlParams.get('sim_config');
            const gachasParam = urlParams.get('gachas');

            if (gachasParam) {
                tableGachaIds = gachasParam.split('-');
            } else if (simConfigParam) {
                tableGachaIds = [];
            } else {
                const gachaKeys = Object.keys(gachaMasterData.gachas);
                if (gachaKeys.length > 0) tableGachaIds.push(gachaKeys[0]);
            }

            if (seedParam) {
                document.getElementById('seed').value = seedParam;
            }
            if (simConfigParam) {
                document.getElementById('sim-config').value = simConfigParam;
            }

            document.getElementById('result').classList.toggle('hidden', !showResultDisplay);
            updateToggleButtons();

            resetAndGenerateTable();
        }
        
        function updateSeedFromSim() {
            if (finalSeedForUpdate) {
                document.getElementById('seed').value = finalSeedForUpdate;
                document.getElementById('sim-config').value = ''; // sim-config をブランクにする
                resetAndGenerateTable(); 
            }
        }

        function addMoreRows(count) {
            currentRolls += count;
            generateRollsTable();
        }

        function resetAndGenerateTable() {
            finalSeedForUpdate = null;
            // sim-config がブランクの場合のみ currentRolls をリセット
            if (document.getElementById('sim-config').value.trim() === '') {
                 currentRolls = 100;
            }
            generateRollsTable();
        }

        function updateGachaSelection(selectElement, index) {
            const originalIdWithG = tableGachaIds[index];
            const isGuaranteed = originalIdWithG.endsWith('g');
            let newId = selectElement.value;
            if (isGuaranteed) {
                newId += 'g';
            }
            tableGachaIds[index] = newId;
            generateRollsTable();
        }

        function addGachaColumn() {
            const gachaKeys = Object.keys(gachaMasterData.gachas);
            if (gachaKeys.length > 0) {
                tableGachaIds.push(gachaKeys[0]);
                generateRollsTable();
            }
        }

        function removeGachaColumn(index) {
            tableGachaIds.splice(index, 1);
            generateRollsTable();
        }

        function toggleSeedColumns() {
            showSeedColumns = !showSeedColumns;
            generateRollsTable(); 
            updateToggleButtons();
        }

        function toggleResultDisplay() {
            showResultDisplay = !showResultDisplay;
            document.getElementById('result').classList.toggle('hidden', !showResultDisplay);
            updateToggleButtons();
        }
        function updateToggleButtons() {
            document.getElementById('toggle-seed-btn').textContent = showSeedColumns ? 'SEEDを非表示' : 'SEEDを表示';
            document.getElementById('toggle-result-btn').textContent = showResultDisplay ? '計算過程を非表示' : '計算過程を表示';
        }

        function updateUrlParams() {
            const seed = document.getElementById('seed').value;
            const simConfig = document.getElementById('sim-config').value;
            const urlParams = new URLSearchParams(window.location.search);

            if (seed) {
                urlParams.set('seed', seed);
            } else {
                urlParams.delete('seed');
            }
            if (simConfig) {
                urlParams.set('sim_config', simConfig);
            } else {
                urlParams.delete('sim_config');
            }
            if (tableGachaIds.length > 0) {
                urlParams.set('gachas', tableGachaIds.join('-'));
            } else {
                urlParams.delete('gachas');
            }

            const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
            window.history.pushState({path: newUrl}, '', newUrl);
        }

        class Xorshift32 { constructor(seed) { this.seed = (seed >>> 0) || 1; } next() { let x = this.seed; x ^= (x << 13); x ^= (x >>> 17); x ^= (x << 15); this.seed = x >>> 0; return this.seed; } }

        function getCharAndRarity(gachaConfig, seed1, seed2) {
            if (!gachaConfig) return { name: "N/A", rarity: null, id: null };
            const rarityRoll = seed1 % 10000;
            const rates = gachaConfig.rarity_rates || {};
            const rareRate = rates.rare || 0, superRate = rates.super || 0, uberRate = rates.uber || 0, legendRate = rates.legend || 0;
            let currentRarity;
            if (rarityRoll < rareRate) { currentRarity = 'rare'; } 
            else if (rarityRoll < rareRate + superRate) { currentRarity = 'super'; } 
            else if (rarityRoll < rareRate + superRate + uberRate) { currentRarity = 'uber'; } 
            else if (rarityRoll < rareRate + superRate + uberRate + legendRate) { currentRarity = 'legend'; } 
            else { currentRarity = 'rare'; }
            
            const characterPool = gachaConfig.pool[currentRarity] || [];
            if (characterPool.length === 0) return { name: "該当なし", rarity: currentRarity, id: null };
            
            const character = characterPool[seed2 % characterPool.length];
            return { ...character, rarity: currentRarity };
        }

        function rollWithSeedConsumption(rng, gachaConfig, lastDrawInfo) {
            const s0_seed = rng.next();
            const rarityRoll = s0_seed % 10000;
            const rates = gachaConfig.rarity_rates || {};
            const rareRate = rates.rare || 0, superRate = rates.super || 0, uberRate = rates.uber || 0, legendRate = rates.legend || 0;
            let currentRarity;
            if (rarityRoll < rareRate) { currentRarity = 'rare'; } else if (rarityRoll < rareRate + superRate) { currentRarity = 'super'; } else if (rarityRoll < rareRate + superRate + uberRate) { currentRarity = 'uber'; } else if (rarityRoll < rareRate + superRate + uberRate + legendRate) { currentRarity = 'legend'; } else { currentRarity = 'rare'; }
            const characterPool = gachaConfig.pool[currentRarity] || [];
            let s1_seed, s2_seed, charIndex, reRollIndex, totalChars, uniqueTotal, isRerolled = false;
            totalChars = characterPool.length;
            if (totalChars === 0) return { s0: s0_seed, rarityRoll, finalChar: { name: "該当なし", id: null }, originalChar: { name: "該当なし", id: null }, isRerolled, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, seedsConsumed: 1 };
            s1_seed = rng.next();
            charIndex = s1_seed % totalChars;
            let character = characterPool[charIndex];
            const originalChar = character;
            let seedsConsumed = 2;
            if (currentRarity === 'rare' && lastDrawInfo && lastDrawInfo.rarity === 'rare' && lastDrawInfo.charId === character.id) {
                const uniqueRareChars = characterPool.filter(c => c.id !== lastDrawInfo.charId);
                uniqueTotal = uniqueRareChars.length;
                if (uniqueTotal > 0) {
                    s2_seed = rng.next();
                    reRollIndex = s2_seed % uniqueTotal;
                    character = uniqueRareChars[reRollIndex];
                    isRerolled = true;
                    seedsConsumed = 3;
                }
            }
            return { s0: s0_seed, s1: s1_seed, s2: s2_seed, rarityRoll, charIndex, reRollIndex, totalChars, uniqueTotal, finalChar: character, originalChar, isRerolled, rarity: currentRarity, charId: character.id, seedsConsumed };
        }

        function rollGuaranteedUber(rng, gachaConfig) {
            const s0_seed = rng.next();
            const currentRarity = 'uber';
            const characterPool = gachaConfig.pool[currentRarity] || [];
            const totalChars = characterPool.length;
            if (totalChars === 0) {
                return { s0: s0_seed, finalChar: { name: "該当なし", id: null }, isRerolled: false, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, seedsConsumed: 1 };
            }
            const charIndex = s0_seed % totalChars;
            const character = characterPool[charIndex];
            return { s0: s0_seed, finalChar: character, originalChar: character, isRerolled: false, rarity: currentRarity, charId: character.id, charIndex: charIndex, totalChars: totalChars, seedsConsumed: 1 };
        }

        function calculateGuaranteedLookahead(startSeedIndex, gachaConfig, allSeeds, initialLastDraw) {
            if (!gachaConfig || !gachaConfig.pool['uber']) return { name: "N/A", nextSeed: null };

            let seedCursor = startSeedIndex;
            let lastDraw = initialLastDraw;

            for (let i = 0; i < 10; i++) {
                if (seedCursor + 1 >= allSeeds.length) return { name: "N/A", nextSeed: null };

                const s1 = allSeeds[seedCursor];
                const s2 = allSeeds[seedCursor + 1];
                const { rarity, id } = getCharAndRarity(gachaConfig, s1, s2);

                if (rarity === 'rare' && lastDraw && lastDraw.rarity === 'rare' && id === lastDraw.charId) {
                    seedCursor += 3;
                    if (seedCursor - 1 >= allSeeds.length) return { name: "N/A", nextSeed: null };
                    const s3 = allSeeds[seedCursor - 1];
                    const uniqueRareChars = (gachaConfig.pool.rare || []).filter(c => c.id !== lastDraw.charId);
                    let nextCharId = id;
                    if (uniqueRareChars.length > 0) {
                        const newChar = uniqueRareChars[s3 % uniqueRareChars.length];
                        nextCharId = newChar.id;
                    }
                    lastDraw = { rarity: 'rare', charId: nextCharId };
                } else {
                    seedCursor += 2;
                    lastDraw = { rarity, charId: id };
                }
            }

            if (seedCursor >= allSeeds.length) return { name: "N/A", nextSeed: null };
            const guaranteedSeed = allSeeds[seedCursor];
            const nextSimSeedValue = (seedCursor + 1 < allSeeds.length) ? allSeeds[seedCursor + 1] : null;

            const uberPool = gachaConfig.pool['uber'] || [];
            if (uberPool.length === 0) return { name: "N/A", nextSeed: nextSimSeedValue };
            const finalChar = uberPool[guaranteedSeed % uberPool.length];
            return { name: finalChar.name, nextSeed: nextSimSeedValue };
        }

        function toggleGuaranteedColumn(index) {
            const idWithG = tableGachaIds[index];
            if (idWithG.endsWith('g')) {
                tableGachaIds[index] = idWithG.slice(0, -1);
            } else {
                tableGachaIds[index] = idWithG + 'g';
            }
            generateRollsTable();
        }

        // --- sim-config ヘルパー関数 ---
        function parseSimConfig(configStr) {
            const configs = [];
            const parts = configStr.split('-');
            for (let i = 0; i < parts.length; i += 2) {
                const id = parts[i];
                const rollStr = parts[i+1];
                if (id && rollStr) {
                    const isGuaranteed = rollStr.endsWith('g');
                    const rolls = parseInt(rollStr.replace('g', ''), 10);
                    configs.push({ id, rolls, g: isGuaranteed });
                }
            }
            return configs;
        }

        function stringifySimConfig(configArr) {
            return configArr.map(c => `${c.id}-${c.rolls}${c.g ? 'g' : ''}`).join('-');
        }

        function incrementLastRoll(configStr) {
            if (!configStr) return null;
            const configs = parseSimConfig(configStr);
            if (configs.length > 0) {
                const last = configs[configs.length - 1];
                if (!last.g) { 
                    last.rolls += 1;
                } else {
                    // 11gの次は1
                    configs.push({ id: last.id, rolls: 1, g: false });
                }
            }
            return stringifySimConfig(configs);
        }
        // --- ヘルパー関数 終了 ---


        function generateRollsTable() {
            try {
                if (Object.keys(gachaMasterData).length === 0) { return; }
                const initialSeed = parseInt(document.getElementById('seed').value, 10);
                const numRolls = currentRolls;
                if (isNaN(initialSeed) || isNaN(numRolls)) {
                    document.getElementById('rolls-table-container').innerHTML = '<p class="error">エラー: 有効な値を入力してください。</p>';
                    return;
                }
                
                // 3. シード値配列の定義と初期化を関数の最初に移動
                const seeds = [];
                const rngForSeeds = new Xorshift32(initialSeed);
                for (let i = 0; i < numRolls * 3 + 220; i++) { seeds.push(rngForSeeds.next()); }

                // 1. sim-config の処理
                const simConfigInput = document.getElementById('sim-config').value.trim();
                let simConfigs = [];
                let simGachaIds = new Set(); // ハイライト対象のガチャID
                let baseConfig = simConfigInput; // リンク計算のベース

                if (simConfigInput) {
                    simConfigs = parseSimConfig(simConfigInput);
                    simConfigs.forEach(sim => {
                        simGachaIds.add(sim.id);
                        if (gachaMasterData.gachas[sim.id]) {
                            sim.gachaConfig = gachaMasterData.gachas[sim.id];
                        }
                        
                        // --- 確定列の重複表示を防ぐ修正 ---
                        const gachaIdInTable = sim.g ? `${sim.id}g` : sim.id;
                        
                        const hasGuaranteed = tableGachaIds.includes(`${sim.id}g`);

                        if (!tableGachaIds.includes(gachaIdInTable)) {
                            if (sim.g) {
                                // XXXg を追加する場合、XXX があっても追加する。
                                tableGachaIds.push(gachaIdInTable);
                            } else {
                                // XXX を追加する場合、XXXg がなければ追加する。
                                if (!hasGuaranteed) {
                                    tableGachaIds.push(gachaIdInTable);
                                }
                            }
                        }
                        // --- 修正箇所 終了 ---

                    });
                } else if (tableGachaIds.length > 0) {
                    // sim-config がブランクの場合、先頭ガチャで 100回シミュ
                    const firstGachaId = tableGachaIds[0].replace('g', '');
                    if (gachaMasterData.gachas[firstGachaId]) {
                        const defaultSimStr = `${firstGachaId}-100`;
                        simConfigs = parseSimConfig(defaultSimStr);
                        simConfigs[0].gachaConfig = gachaMasterData.gachas[firstGachaId];
                        simGachaIds.add(firstGachaId);
                    }
                    baseConfig = ''; // ブランク時はベースもブランク
                }
                
                const uniqueGachaIds = [...new Set(tableGachaIds.map(id => id.replace('g', '')))];
                const gachaConfigs = uniqueGachaIds.map(id => gachaMasterData.gachas[id]).filter(Boolean);

                // 2. シミュレーション実行 (ハイライトと計算過程のため)
                const simulationResults = [];
                const highlightMap = new Map(); // key 'row-track' -> 'gachaId'
                let anchorInfo = null;
                
                const rngForText = new Xorshift32(initialSeed);
                let lastDrawForText = { rarity: null, charId: null };

                let seedCursor = 0;
                let lastDrawForHighlight = { rarity: null, charId: null };
                let totalSimRolls = 0;
                let lastSimRow = -1; // 0-indexed

                if (simConfigs.length > 0) {
                    for (const sim of simConfigs) {
                        if (!sim.gachaConfig) continue; 

                        if (sim.g && sim.rolls === 11) {
                            // 11連確定
                            if (!anchorInfo) { 
                                anchorInfo = { row: Math.floor(seedCursor / 2), track: (seedCursor % 2 === 0) ? 'A' : 'B', gachaId: sim.id };
                            }
                            for (let i = 0; i < 10; i++) {
                                if (seedCursor + 1 >= seeds.length) break;

                                const row = Math.floor(seedCursor / 2);
                                const track = (seedCursor % 2 === 0) ? 'A' : 'B';
                                if (row >= numRolls) break;
                                
                                lastSimRow = row; // 10回目のロールまでハイライト
                                highlightMap.set(`${row}-${track}`, sim.id);
                                
                                const s1 = seeds[seedCursor];
                                const s2 = seeds[seedCursor + 1];
                                const { rarity, id } = getCharAndRarity(sim.gachaConfig, s1, s2);
                                
                                let seedsConsumed = 2;
                                if (rarity === 'rare' && lastDrawForHighlight.rarity === 'rare' && id === lastDrawForHighlight.charId) {
                                    seedsConsumed = 3;
                                }
                                lastDrawForHighlight = { rarity, charId: id };
                                seedCursor += seedsConsumed;

                                const resultForText = rollWithSeedConsumption(rngForText, sim.gachaConfig, lastDrawForText);
                                simulationResults.push({ ...sim, result: resultForText, track: track, isGuaranteed: false, rollNum: ++totalSimRolls });
                                lastDrawForText = resultForText;
                            }
                            // 11回目（確定）
                            const row = Math.floor(seedCursor / 2);
                            const track = (seedCursor % 2 === 0) ? 'A' : 'B';
                            
                            // 確定ロール自体はハイライトしないが、次のロールの開始位置を設定するために lastSimRow は更新する
                            lastSimRow = row; 
                            // highlightMap.set(`${row}-${track}-G`, sim.id); // <--- この行を削除/スキップ

                            const guaranteedResult = rollGuaranteedUber(rngForText, sim.gachaConfig);
                            simulationResults.push({ ...sim, result: guaranteedResult, track: track, isGuaranteed: true, rollNum: ++totalSimRolls });
                            lastDrawForText = guaranteedResult; 
                            seedCursor += 1; 
                            
                        } else {
                            // 通常ロール
                            for (let i = 0; i < sim.rolls; i++) {
                                const row = Math.floor(seedCursor / 2);
                                const track = (seedCursor % 2 === 0) ? 'A' : 'B';
                                if (row >= numRolls) break;
                                lastSimRow = row;
                                highlightMap.set(`${row}-${track}`, sim.id);

                                const s1 = seeds[seedCursor];
                                const s2 = seeds[seedCursor + 1];
                                const { rarity, id } = getCharAndRarity(sim.gachaConfig, s1, s2);

                                let seedsConsumed = 2;
                                if (rarity === 'rare' && lastDrawForHighlight.rarity === 'rare' && id === lastDrawForHighlight.charId) {
                                    seedsConsumed = 3;
                                }
                                lastDrawForHighlight = { rarity, charId: id };
                                seedCursor += seedsConsumed;

                                const resultForText = rollWithSeedConsumption(rngForText, sim.gachaConfig, lastDrawForText);
                                simulationResults.push({ ...sim, result: resultForText, track: track, isGuaranteed: false, rollNum: ++totalSimRolls });
                                lastDrawForText = resultForText;
                            }
                        }
                    }
                }
                finalSeedForUpdate = rngForText.seed;
                
                // 3. テーブルデータとレア被りマップの準備
                const tableData = Array(numRolls).fill(null).map(() => ({ A: [], B: [] }));
                const rerollMap = new Map(); // key 'A-i-id' -> bool
                
                function isRareDupe(cell, prevCell) {
                    if (!cell || !prevCell || !cell.char || !prevCell.char) return false;
                    return cell.rarity === 'rare' && prevCell.rarity === 'rare' && cell.char.id === prevCell.char.id;
                }

                gachaConfigs.forEach(config => {
                    if (!config) return;
                    // let gachaIndex = tableData[0].A.length; // 挿入先のインデックス
                    let prevCellA = null;
                    let prevCellB = null;

                    for (let i = 0; i < numRolls; i++) {
                        if ((2 * i + 2) >= seeds.length) break; 
                        const charA = getCharAndRarity(config, seeds[2 * i], seeds[2 * i + 1]);
                        const cellA = { gachaId: config.id, char: charA, rarity: charA.rarity };
                        tableData[i].A.push(cellA);
                        rerollMap.set(`A-${i}-${config.id}`, isRareDupe(cellA, prevCellA));
                        prevCellA = cellA;

                        const charB = getCharAndRarity(config, seeds[2 * i + 1], seeds[2 * i + 2]);
                        const cellB = { gachaId: config.id, char: charB, rarity: charB.rarity };
                        tableData[i].B.push(cellB);
                        rerollMap.set(`B-${i}-${config.id}`, isRareDupe(cellB, prevCellB));
                        prevCellB = cellB;
                    }
                });


                // 4. リンク(sim-config)マップの計算
                const cellSimConfigs = new Map(); // key 'A-i-id' -> "sim-config-string" or null
                
                // --- 修正: 継続の開始位置を正確に計算 ---
                let startSeedIndex = seedCursor;
                let startRow = Math.floor(startSeedIndex / 2);
                let startTrack = (startSeedIndex % 2 === 0) ? 'A' : 'B';
                let newRow1Index = startRow; 
                
                if (baseConfig === '') {
                    newRow1Index = 0;
                    startTrack = 'A'; // 最初は必ずAから
                }
                // --- 修正 終了 ---


                for (let i = 0; i < numRolls; i++) {
                    gachaConfigs.forEach(config => {
                        const id = config.id;
                        let configA = null;
                        let configB = null;

                        if (i < newRow1Index) {
                            // FIXされた行
                             if (i === 0) {
                                configA = `${id}-1`;
                                configB = null;
                            } else {
                                const parentConfigA = cellSimConfigs.get(`A-${i-1}-${id}`);
                                const parentConfigB = cellSimConfigs.get(`B-${i-1}-${id}`);
                                const isReroll_A_prev = rerollMap.get(`A-${i-1}-${id}`);
                                const isReroll_B_prev = rerollMap.get(`B-${i-1}-${id}`);
                                if (isReroll_B_prev && parentConfigB) { configA = incrementLastRoll(parentConfigB); }
                                else if (parentConfigA) { configA = incrementLastRoll(parentConfigA); }
                                else { configA = null; }

                                if (isReroll_A_prev && parentConfigA) { configB = incrementLastRoll(parentConfigA); }
                                else if (parentConfigB) { configB = incrementLastRoll(parentConfigB); }
                                else { configB = null; }
                            }
                        } else if (i === newRow1Index) {
                            // "新しい1行目" (FIX & Continueの開始点)
                            
                            // --- 修正: startTrackに応じて開始列を決定 ---
                            if (startTrack === 'A') {
                                configA = `${baseConfig ? baseConfig + '-' : ''}${id}-1`;
                                configB = null; // B列1行目は常にnull
                            } else { // startTrack === 'B'
                                configA = null; // A列はスキップ
                                configB = `${baseConfig ? baseConfig + '-' : ''}${id}-1`;
                            }
                            // --- 修正 終了 ---
                            
                        } else {
                            // "新しい2行目" 以降
                            const parentConfigA = cellSimConfigs.get(`A-${i-1}-${id}`);
                            const parentConfigB = cellSimConfigs.get(`B-${i-1}-${id}`);
                            const isReroll_A_prev = rerollMap.get(`A-${i-1}-${id}`);
                            const isReroll_B_prev = rerollMap.get(`B-${i-1}-${id}`);

                            // A-i Logic
                            if (isReroll_B_prev && parentConfigB) {
                                configA = incrementLastRoll(parentConfigB); // (2) レア被りによるジャンプ
                            } else if (parentConfigA) {
                                configA = incrementLastRoll(parentConfigA); // (1) 通常ルート
                            } else {
                                configA = null; // 継承 (親がnullなら子もnull)
                            }

                            // B-i Logic
                            if (isReroll_A_prev && parentConfigA) {
                                configB = incrementLastRoll(parentConfigA); // (2) レア被りによるジャンプ
                            } else if (parentConfigB) {
                                configB = incrementLastRoll(parentConfigB); // (1) 通常ルート
                            } else {
                                configB = null; // 継承
                            }
                        }

                        cellSimConfigs.set(`A-${i}-${id}`, configA);
                        cellSimConfigs.set(`B-${i}-${id}`, configB);
                    });
                }


                // 5. HTMLテーブルの構築
                const buttonHtml = `<button class="add-gacha-btn" onclick="addGachaColumn()">＋</button>`;
                let totalColsA = 0;
                tableGachaIds.forEach(idWithG => {
                    const id = idWithG.replace('g', '');
                    if (gachaMasterData.gachas[id]) {
                        totalColsA += idWithG.endsWith('g') ? 2 : 1;
                    }
                });
                
                const seedColClass = `seed-column ${showSeedColumns ? '' : 'hidden'}`;

                let tableHtml = `<table><thead>
                    <tr>
                        <th rowspan="2" class="col-no">NO.</th>
                        <th rowspan="2" class="${seedColClass}">SEED 1</th>
                        <th rowspan="2" class="${seedColClass}">SEED 2</th>
                        <th colspan="${totalColsA}">A ${buttonHtml}</th>
                        <th rowspan="2" class="col-no">NO.</th>
                        <th rowspan="2" class="${seedColClass}">SEED 1</th>
                        <th rowspan="2" class="${seedColClass}">SEED 2</th>
                        <th colspan="${totalColsA}">B</th>
                    </tr>
                    <tr>`;
                
                // Headers for Track A
                tableGachaIds.forEach((idWithG, index) => {
                    const isGuaranteed = idWithG.endsWith('g');
                    const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                    const gachaConfig = gachaMasterData.gachas[id];
                    if (!gachaConfig) return;

                    const removeButtonHtml = `<button onclick="removeGachaColumn(${index})">x</button>`;
                    const gButtonHtml = `<button onclick="toggleGuaranteedColumn(${index})">G</button>`;
                    let selectorHtml = `<select onchange="updateGachaSelection(this, ${index})">`;
                    Object.keys(gachaMasterData.gachas).forEach(gachaId => {
                        selectorHtml += `<option value="${gachaId}" ${gachaId === id ? 'selected' : ''}>${gachaMasterData.gachas[gachaId].name}</option>`;
                    });
                    selectorHtml += '</select>';
                    const headerName = `${gachaConfig.name} (ID: ${gachaConfig.id})`;

                    if (isGuaranteed) {
                        tableHtml += `<th colspan="2"><div class="gacha-select-header">${selectorHtml}<span>${headerName}</span><br/>${gButtonHtml}${removeButtonHtml}</div></th>`;
                    } else {
                        tableHtml += `<th><div class="gacha-select-header">${selectorHtml}<span>${headerName}</span><br/>${gButtonHtml}${removeButtonHtml}</div></th>`;
                    }
                });

                // Headers for Track B
                tableGachaIds.forEach((idWithG, index) => {
                    const isGuaranteed = idWithG.endsWith('g');
                    const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                    const gachaConfig = gachaMasterData.gachas[id];
                    if (!gachaConfig) return;
                    const headerName = `${gachaConfig.name} (ID: ${gachaConfig.id})`;

                    if (isGuaranteed) {
                        tableHtml += `<th colspan="2">${headerName}</th>`;
                    } else {
                        tableHtml += `<th>${headerName}</th>`;
                    }
                });

                tableHtml += `</tr></thead><tbody>`;

                for (let i = 0; i < numRolls; i++) {
                    let rowHtml = `<tr><td class="col-no">${i + 1}</td>`;
                    rowHtml += `<td class="${seedColClass}">${seeds[2 * i]}</td><td class="${seedColClass}">${seeds[2 * i + 1]}</td>`;
                    
                    tableGachaIds.forEach(idWithG => {
                        const isGuaranteed = idWithG.endsWith('g');
                        const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                        const gachaConfig = gachaMasterData.gachas[id];
                        if (!gachaConfig) return; 
                        
                        const gachaIndex = gachaConfigs.findIndex(c => c.id === id);
                        if (gachaIndex === -1 || !tableData[i] || !tableData[i].A[gachaIndex] || !tableData[i].A[gachaIndex].char) {
                            rowHtml += `<td>N/A</td>`; if (isGuaranteed) rowHtml += `<td>N/A</td>`; return;
                        }
                        const cellDataA = tableData[i].A[gachaIndex];
                        
                        const highlightGachaIdA = highlightMap.get(`${i}-A`);
                        // 確定枠自体はハイライトしないが、確定枠のアンカーがある場合はハイライトを付ける
                        const highlightGachaIdG_A = highlightMap.get(`${i}-A-G`); 
                        const highlightClass = (highlightGachaIdA === id || highlightGachaIdG_A === id) ? ' class="highlight"' : '';
                        
                        const configStrA = cellSimConfigs.get(`A-${i}-${id}`);
                        
                        if (configStrA) {
                            const hrefA = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configStrA)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickActionA = `event.preventDefault(); document.getElementById('sim-config').value = '${configStrA}'; resetAndGenerateTable();`;
                            rowHtml += `<td${highlightClass}><a href="${hrefA}" onclick="${onclickActionA}">${cellDataA.char.name}</a></td>`;
                        } else {
                             rowHtml += `<td${highlightClass}>${cellDataA.char.name}</td>`;
                        }
                        
                        if (isGuaranteed) {
                            let lastDraw = (i > 0 && tableData[i-1] && tableData[i-1].A[gachaIndex] && tableData[i-1].A[gachaIndex].char) ? { rarity: tableData[i-1].A[gachaIndex].rarity, charId: tableData[i-1].A[gachaIndex].char.id } : null;
                            const { name: guaranteedChar, nextSeed } = calculateGuaranteedLookahead(i * 2, gachaConfig, seeds, lastDraw);
                            
                            // 確定枠自体はハイライトしない
                            let guaranteedHighlight = '';
                            
                            let content = guaranteedChar;
                            const isAnchor = (anchorInfo && anchorInfo.row === i && anchorInfo.track === 'A' && anchorInfo.gachaId === id);

                            // G列のリンクは、A列がリンクの場合のみ生成
                            if (configStrA) {
                                const parsedA = parseSimConfig(configStrA);
                                const lastPartA = parsedA.pop();
                                
                                // 確定列の sim-config ロジック: 通常ロールの最後のロール数を-1し、ID+11gを付加
                                if (lastPartA && lastPartA.rolls > 0) { 
                                    lastPartA.rolls -= 1;
                                    if (lastPartA.rolls > 0) parsedA.push(lastPartA);
                                    parsedA.push({ id: id, rolls: 11, g: true });
                                    const configG_A = stringifySimConfig(parsedA);

                                    const hrefG = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configG_A)}&gachas=${tableGachaIds.join('-')}`;
                                    const onclickActionG = `event.preventDefault(); document.getElementById('sim-config').value = '${configG_A}'; resetAndGenerateTable();`;
                                    // ⚓マークを削除
                                    content = `<a href="${hrefG}" onclick="${onclickActionG}">${guaranteedChar}</a>`;
                                }
                            }
                            if (isAnchor && content === guaranteedChar) { // アンカーだがリンクがなかった場合
                                // ⚓マークを削除
                                content = `${guaranteedChar}`;
                            }
                            if (isAnchor) guaranteedHighlight = ' class="highlight"';
                            
                            rowHtml += `<td${guaranteedHighlight}>${content}</td>`;
                        }
                    });

                    rowHtml += `<td class="col-no">${i + 1}</td>`;
                    rowHtml += `<td class="${seedColClass}">${seeds[2 * i + 1]}</td><td class="${seedColClass}">${seeds[2 * i + 2]}</td>`;

                    tableGachaIds.forEach(idWithG => {
                        const isGuaranteed = idWithG.endsWith('g');
                        const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                        const gachaConfig = gachaMasterData.gachas[id];
                        if (!gachaConfig) return;

                        const gachaIndex = gachaConfigs.findIndex(c => c.id === id);
                        if (gachaIndex === -1 || !tableData[i] || !tableData[i].B[gachaIndex] || !tableData[i].B[gachaIndex].char) {
                            rowHtml += `<td>N/A</td>`; if (isGuaranteed) rowHtml += `<td>N/A</td>`; return;
                        }
                        const cellDataB = tableData[i].B[gachaIndex];
                        
                        const highlightGachaIdB = highlightMap.get(`${i}-B`);
                        const highlightGachaIdG_B = highlightMap.get(`${i}-B-G`);
                        const highlightClass = (highlightGachaIdB === id || highlightGachaIdG_B === id) ? ' class="highlight"' : '';
                        
                        const configStrB = cellSimConfigs.get(`B-${i}-${id}`);

                        if (configStrB) {
                            const hrefB = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configStrB)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickActionB = `event.preventDefault(); document.getElementById('sim-config').value = '${configStrB}'; resetAndGenerateTable();`;
                            rowHtml += `<td${highlightClass}><a href="${hrefB}" onclick="${onclickActionB}">${cellDataB.char.name}</a></td>`;
                        } else {
                            rowHtml += `<td${highlightClass}>${cellDataB.char.name}</td>`;
                        }

                        if (isGuaranteed) {
                             let lastDraw = (i > 0 && tableData[i-1] && tableData[i-1].B[gachaIndex] && tableData[i-1].B[gachaIndex].char) ? { rarity: tableData[i-1].B[gachaIndex].rarity, charId: tableData[i-1].B[gachaIndex].char.id } : null;
                             const { name: guaranteedChar, nextSeed } = calculateGuaranteedLookahead(i * 2 + 1, gachaConfig, seeds, lastDraw);
                             
                             let guaranteedHighlight = '';
                             
                             let content = guaranteedChar;
                             const isAnchor = (anchorInfo && anchorInfo.row === i && anchorInfo.track === 'B' && anchorInfo.gachaId === id);

                             if (configStrB) {
                                const parsedB = parseSimConfig(configStrB);
                                const lastPartB = parsedB.pop();
                                
                                // 確定列の sim-config ロジック: 通常ロールの最後のロール数を-1し、ID+11gを付加
                                if(lastPartB && lastPartB.rolls > 0) {
                                    lastPartB.rolls -= 1;
                                    if (lastPartB.rolls > 0) parsedB.push(lastPartB);
                                    parsedB.push({ id: id, rolls: 11, g: true });
                                    const configG_B = stringifySimConfig(parsedB);
                                    
                                    const hrefG = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configG_B)}&gachas=${tableGachaIds.join('-')}`;
                                    const onclickActionG = `event.preventDefault(); document.getElementById('sim-config').value = '${configG_B}'; resetAndGenerateTable();`;
                                    // ⚓マークを削除
                                    content = `<a href="${hrefG}" onclick="${onclickActionG}">${guaranteedChar}</a>`;
                                }
                             }
                             if (isAnchor && content === guaranteedChar) {
                                 // ⚓マークを削除
                                content = `${guaranteedChar}`;
                             }
                             if (isAnchor) guaranteedHighlight = ' class="highlight"';
                             
                             rowHtml += `<td${guaranteedHighlight}>${content}</td>`;
                        }
                    });
                    
                    rowHtml += `</tr>`;
                    tableHtml += rowHtml;
                }

                tableHtml += '</tbody></table>';
                document.getElementById('rolls-table-container').innerHTML = tableHtml;

                let simulationOutputString = '--- シミュレーション詳細 ---\n';
                if (simulationResults.length > 0) {
                    simulationResults.forEach((sim, index) => {
                        if (!sim || !sim.result) return;
                        const result = sim.result;
                        let line;
                        if (sim.isGuaranteed) {
                             line = `[${sim.rollNum}回目] ${sim.track} | GachaID: ${sim.id} | uber guaranteed ${result.s0}(%${result.totalChars}=${result.charIndex}) ${result.finalChar.name}`;
                        } else {
                            line = `[${sim.rollNum}回目] ${sim.track} | GachaID: ${sim.id} | ${result.s0}(${result.rarityRoll})${result.rarity}`;
                            if (result.isRerolled) {
                                line += ` ${result.originalChar.name} -> ${result.s2}(%${result.uniqueTotal}=${result.reRollIndex}) ${result.finalChar.name}`;
                            } else {
                                line += `／${result.s1}(%${result.totalChars}=${result.charIndex}) ${result.finalChar.name}`;
                            }
                        }
                        simulationOutputString += line + '\n';
                    });
                }
                document.getElementById('result').textContent = simulationOutputString;

                updateUrlParams();
            } catch (e) {
                document.getElementById('rolls-table-container').innerHTML = `<p class="error">テーブルの生成中にエラーが発生しました: ${e.message}</p>`;
                document.getElementById('result').textContent = `エラー: ${e.stack}`; // エラー詳細を表示
                console.error(e);
            }
        }

        window.onload = loadAndProcessData;
    </script>
</body>
</html>