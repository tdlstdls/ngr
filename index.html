<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>なんちゃってレアガチャロールズ</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; }
        #controls label, #controls input, #controls button { margin-right: 10px; margin-bottom: 10px; display: inline-block; }
        .error { color: red; font-weight: bold; }
        table { border-collapse: collapse; width: 100%; margin-top: 10px; /* Removed table-layout: fixed; */ }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        /* Removed th:not, td:not rule that set width: 100% */
        th { background-color: #f2f2f2; text-align: center; vertical-align: middle; position: relative; }
        .highlight { background-color: #ffff99; }
        .gacha-select-header { display: flex; align-items: center; justify-content: center; flex-wrap: wrap; }
        .gacha-select-header span { margin-left: 5px; font-size: 12px; }
        .gacha-select-header select {
            width: 20px; /* 幅を最小に */
            -webkit-appearance: none; /* Safari, Chrome */
            -moz-appearance: none; /* Firefox */
            appearance: none; /* 標準 */
            background: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 4 5'%3E%3Cpath fill='%23333' d='M2 0L0 2h4zm0 5L0 3h4z'/%3E%3C/svg%3E") no-repeat right / .8em; /* 矢印アイコン */
            padding-right: 1em; /* アイコンのスペース */
        }
        .gacha-select-header button { font-size: 10px; padding: 2px 4px; margin-left: 4px; }
        .add-gacha-btn { font-size: 12px; font-weight: normal; padding: 2px 6px; margin-left: 15px; }
        #result { margin-top: 20px; border: 1px solid #ccc; padding: 10px; white-space: pre-wrap; font-family: monospace; background-color: #f9f9f9; max-height: 300px; overflow-y: auto; }
        #table-actions { text-align: center; margin-top: 20px; }
        #table-actions button { margin: 0 5px; }

        /* Toggle visibility classes */
        .hidden { display: none; }
        .seed-column { width: 90px; text-align: center; font-size: 10px; color: #555; }
        .col-no { width: 45px; text-align: center; white-space: nowrap; }

        @media screen and (max-width: 768px) {
            body {
                padding: 5px;
                -webkit-text-size-adjust: 100%;
            }
            h1 {
                font-size: 1.2em;
            }
            #controls {
                padding: 10px;
            }
            #controls label,
            #controls input,
            #controls button {
                display: block;
                width: 95%;
                margin: 0 auto 10px auto;
                box-sizing: border-box;
            }
            #rolls-table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            table {
                width: auto;
                min-width: 800px;
            }
            th, td {
                padding: 8px 6px;
                font-size: 13px;
                line-height: 1.4;
            }
            td.gacha-cell {
                word-break: break-word;
            }
            .gacha-select-header span {
                font-size: 10px;
            }
        }
    </style>
</head>
<body>
    <h1>なんちゃってGachaRolls（gr）シミュレーター（レアロールズ）</h1>

    <div id="controls">
        <label for="seed">SEED:</label>
        <input type="number" id="seed" value="12345" min="1" max="4294967295" onchange="resetAndGenerateTable()">
        <button onclick="updateSeedFromSim()">SEED更新</button>
        <label for="sim-config">シミュレーション:</label>
        <input type="text" id="sim-config" placeholder="ガチャID-ロール数" onchange="resetAndGenerateTable()">
    </div>

    <div id="rolls-table-container"></div>
    <div id="table-actions">
        <button onclick="addMoreRows(100)">100行追加する</button>
        <button id="toggle-seed-btn" onclick="toggleSeedColumns()">SEEDを表示</button>
        <button id="toggle-result-btn" onclick="toggleResultDisplay()">計算過程を表示</button>
    </div>
    <div id="result"></div>

    <script>
        let gachaMasterData = {};
        const dataFiles = ['data/cats.js', 'data/events.js', 'data/gacha.js'];
        let tableGachaIds = [];
        let currentRolls = 100;
        let showSeedColumns = false;
        let showResultDisplay = false;
        let finalSeedForUpdate = null; // SEED更新ボタン用

        const fallbackCats = [
            {id:31,name:"ネコぼさつ",rarity:3},{id:32,name:"ネコ番長",rarity:3},{id:33,name:"ネコザイル",rarity:3},{id:34,name:"ねこタツ",rarity:3},{id:35,name:"ネコルガ",rarity:4},{id:36,name:"オタネコ",rarity:3},{id:37,name:"ネコスイマー",rarity:3},{id:38,name:"ネコホッピング",rarity:2},{id:39,name:"ネコ車輪",rarity:2},{id:40,name:"ネコリンゴ",rarity:3},{id:41,name:"ネコバスたぶ",rarity:3},{id:42,name:"ネコエステ",rarity:2},{id:43,name:"ネコアイス",rarity:4},{id:44,name:"ネコマシン",rarity:4},{id:45,name:"鬼にゃんま",rarity:4},{id:47,name:"ねこジュラ",rarity:2},{id:48,name:"ねこファイター",rarity:2},{id:49,name:"ねこ海賊",rarity:2},{id:50,name:"ねこ泥棒",rarity:2},{id:51,name:"ねこ僧侶",rarity:2},{id:52,name:"ねこ占い師",rarity:2},{id:53,name:"ネコシャーマン",rarity:2},{id:56,name:"ネコ魔女",rarity:2},{id:57,name:"ネコアーチャー",rarity:2},{id:58,name:"ネコシュバリエ",rarity:4},{id:59,name:"ネコ魔剣士",rarity:2},{id:60,name:"ねこベビー",rarity:4},{id:62,name:"ねこ寿司",rarity:3},{id:76,name:"風神のウィンディ",rarity:4},{id:84,name:"地龍ソドム",rarity:4},{id:85,name:"聖龍メギドラ",rarity:4},{id:107,name:"召し豚のカイ",rarity:4},{id:108,name:"宝杖のカッパーマイン",rarity:4},{id:130,name:"金ネコ",rarity:3},{id:132,name:"ねねこ",rarity:3},{id:136,name:"ツルの恩返し",rarity:4},{id:144,name:"ねこナース",rarity:4},{id:145,name:"にゃんこ城Mini",rarity:3},{id:146,name:"ねこガンマン",rarity:2},{id:147,name:"たけうまねこ",rarity:2},{id:148,name:"ブリキネコ",rarity:2},{id:149,name:"ねこロッカー",rarity:2},{id:150,name:"ねこ人魚",rarity:2},{id:151,name:"窓辺の乙女ネコ",rarity:3},{id:152,name:"ネコバーベル",rarity:3},{id:153,name:"ネコスケート",rarity:3},{id:154,name:"ネコトースター",rarity:3},{id:169,name:"アシルガ",rarity:4},{id:170,name:"クビルガ",rarity:4},{id:171,name:"テコルガ",rarity:4},{id:172,name:"バララガ",rarity:4},{id:197,name:"キャットマンダディ",rarity:4},{id:198,name:"サイキックネコ",rarity:2},{id:199,name:"ねこ陰陽師",rarity:2},{id:200,name:"ネコサーファー",rarity:3},{id:201,name:"メタルネコ",rarity:3},{id:238,name:"おかめはちもくネコ",rarity:3},{id:239,name:"ボンボンネコ",rarity:3},{id:240,name:"見習いスニャイパー",rarity:3},{id:241,name:"トゲルガ",rarity:4},{id:258,name:"天空神ゼウス",rarity:4},{id:259,name:"守護神アヌビス",rarity:4},{id:260,name:"美女神アフロディーテ",rarity:4},{id:272,name:"太陽神アマテラス",rarity:4},{id:273,name:"繁栄神ガネーシャ",rarity:4},{id:287,name:"閃雷機兵レイ",rarity:4},{id:308,name:"ネコジャンパー",rarity:3},{id:309,name:"ネコバサミ",rarity:2},{id:317,name:"海王神ポセイドン",rarity:4},{id:326,name:"ネコボクサー",rarity:2},{id:377,name:"ネコ探査機",rarity:2},{id:378,name:"ネコフェンシング",rarity:3},{id:440,name:"時空神クロノス",rarity:4},{id:444,name:"ネコ医師",rarity:2},{id:445,name:"ネコ占い師",rarity:2},{id:446,name:"ネコシャーマン",rarity:2},{id:447,name:"ネコ魔女",rarity:2},{id:448,name:"ネコアーチャー",rarity:2},{id:494,name:"竜騎士バルス",rarity:4},{id:496,name:"ネコパーフェクト",rarity:3},{id:523,name:"ネコ武闘家",rarity:2},{id:524,name:"ネコ法師",rarity:2},{id:535,name:"竜戦機ライデン",rarity:4},{id:643,name:"神龍かむくら",rarity:4},{id:724,name:"聖龍メギドラ",rarity:4},{id:812,name:"地龍ソドム",rarity:4}
        ];
        const fallbackEvents = [
            {id:992,name:"波動バスターズ",rare:7000,supa:2500,uber:500},
            {id:452,name:"エアバスターズ",rare:7000,supa:2500,uber:500},
            {id:523,name:"ギガントゼウス",rare:7000,supa:2500,uber:500}
        ];
        const fallbackGacha = [
            {id:992,cats:[812,724,643,535,494,440,317,273,272,260,259,258,448,447,446,445,444,201,145,132,130,238,239,240,524,523,496,378,377,326,308,309,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]},
            {id:452,cats:[524,523,496,378,377,326,308,309,287,197,144,136,108,107,85,84,76,60,240,239,238,201,145,132,130,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]},
            {id:523,cats:[524,523,496,378,377,326,308,309,287,197,144,136,108,107,85,84,76,60,240,239,238,201,145,132,130,200,199,198,154,153,152,151,150,149,148,147,146,62,59,57,56,53,52,51,50,49,48,47,42,41,40,39,38,37,36,34,33,32,31]}
        ];

        async function loadAndProcessData() {
            const loadedData = {};
            try {
                for (const file of dataFiles) {
                    const response = await fetch(file);
                    if (!response.ok) throw new Error('Network response was not ok.');
                    const text = await response.text();
                    const jsonStr = text.substring(text.indexOf('['), text.lastIndexOf(']') + 1);
                    loadedData[file.split('/')[1].split('.')[0]] = JSON.parse(jsonStr);
                }
            } catch (e) {
                console.warn("Failed to load external data, using fallback data.", e);
                loadedData.cats = fallbackCats;
                loadedData.events = fallbackEvents;
                loadedData.gacha = fallbackGacha;
            }

            const rarityMap = { 0: "nomal", 1: "ex", 2: "rare", 3: "super", 4: "uber", 5: "legend" };
            const catsMaster = {};
            for (const cat of loadedData.cats) { catsMaster[cat.id] = { ...cat, rarity: rarityMap[cat.rarity] || "rare" }; }
            const eventsMaster = {};
            for (const event of loadedData.events) { eventsMaster[event.id] = event; }
            const gachasMaster = {};
            for (const gacha of loadedData.gacha) {
                const eventInfo = eventsMaster[gacha.id];
                if (!eventInfo) continue;
                const pool = { rare: [], super: [], uber: [], legend: [], nomal: [], ex: [] };
                if (gacha.cats) {
                    for (const catId of gacha.cats) {
                        const catInfo = catsMaster[catId];
                        if (catInfo && pool[catInfo.rarity] !== undefined) pool[catInfo.rarity].push({ id: catInfo.id, name: catInfo.name });
                    }
                }
                gachasMaster[gacha.id] = {
                    id: gacha.id.toString(),
                    name: eventInfo.name || gacha.name || `ガチャID: ${gacha.id}`,
                    rarity_rates: { rare: eventInfo.rare || 0, super: eventInfo.supa || 0, uber: eventInfo.uber || 0, legend: eventInfo.legend || 0 },
                    pool: pool
                };
            }
            gachaMasterData = { cats: catsMaster, gachas: gachasMaster };

            const urlParams = new URLSearchParams(window.location.search);
            const seedParam = urlParams.get('seed');
            const simConfigParam = urlParams.get('sim_config');
            const gachasParam = urlParams.get('gachas');

            if (gachasParam) {
                tableGachaIds = gachasParam.split('-');
            } else if (simConfigParam) {
                tableGachaIds = [];
            } else {
                const gachaKeys = Object.keys(gachaMasterData.gachas);
                if (gachaKeys.length > 0) tableGachaIds.push(gachaKeys[0]);
            }

            if (seedParam) {
                document.getElementById('seed').value = seedParam;
            }
            if (simConfigParam) {
                document.getElementById('sim-config').value = simConfigParam;
            }

            document.getElementById('result').classList.toggle('hidden', !showResultDisplay);
            updateToggleButtons();

            resetAndGenerateTable();
        }
        
        function updateSeedFromSim() {
            if (finalSeedForUpdate) {
                document.getElementById('seed').value = finalSeedForUpdate;
                document.getElementById('sim-config').value = ''; // sim-config をブランクにする
                resetAndGenerateTable(); 
            }
        }

        function addMoreRows(count) {
            currentRolls += count;
            generateRollsTable();
        }

        function resetAndGenerateTable() {
            finalSeedForUpdate = null;
            // sim-config がブランクの場合のみ currentRolls をリセット
            if (document.getElementById('sim-config').value.trim() === '') {
                 currentRolls = 100;
            }
            generateRollsTable();
        }

        function updateGachaSelection(selectElement, index) {
            const originalIdWithG = tableGachaIds[index];
            const isGuaranteed = originalIdWithG.endsWith('g');
            let newId = selectElement.value;
            if (isGuaranteed) {
                newId += 'g';
            }
            tableGachaIds[index] = newId;
            generateRollsTable();
        }

        function addGachaColumn() {
            const gachaKeys = Object.keys(gachaMasterData.gachas);
            if (gachaKeys.length > 0) {
                tableGachaIds.push(gachaKeys[0]);
                generateRollsTable();
            }
        }

        function removeGachaColumn(index) {
            tableGachaIds.splice(index, 1);
            generateRollsTable();
        }

        function toggleSeedColumns() {
            showSeedColumns = !showSeedColumns;
            generateRollsTable(); 
            updateToggleButtons();
        }

        function toggleResultDisplay() {
            showResultDisplay = !showResultDisplay;
            document.getElementById('result').classList.toggle('hidden', !showResultDisplay);
            updateToggleButtons();
        }
        function updateToggleButtons() {
            document.getElementById('toggle-seed-btn').textContent = showSeedColumns ? 'SEEDを非表示' : 'SEEDを表示';
            document.getElementById('toggle-result-btn').textContent = showResultDisplay ? '計算過程を非表示' : '計算過程を表示';
        }

        function updateUrlParams() {
            const seed = document.getElementById('seed').value;
            const simConfig = document.getElementById('sim-config').value;
            const urlParams = new URLSearchParams(window.location.search);

            if (seed) {
                urlParams.set('seed', seed);
            } else {
                urlParams.delete('seed');
            }
            if (simConfig) {
                urlParams.set('sim_config', simConfig);
            } else {
                urlParams.delete('sim_config');
            }
            if (tableGachaIds.length > 0) {
                urlParams.set('gachas', tableGachaIds.join('-'));
            } else {
                urlParams.delete('gachas');
            }

            const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
            // ★ 修正: history.pushState を try...catch で囲む
            try {
                window.history.pushState({path: newUrl}, '', newUrl);
            } catch (e) {
                console.warn("Could not update URL parameters:", e.message);
                // サンドボックス環境 (blob: や iframe) では pushState が失敗することがある
                // アプリの実行を継続するためにエラーを無視する
            }
        }

        class Xorshift32 { constructor(seed) { this.seed = (seed >>> 0) || 1; } next() { let x = this.seed; x ^= (x << 13); x ^= (x >>> 17); x ^= (x << 15); this.seed = x >>> 0; return this.seed; } }

        
        /**
         * 固定シード配列と開始インデックスを用いてガチャを一回実行し、シード消費を含む詳細を返す
         * @param {number} startIndex - seeds配列の開始インデックス
         * @param {object} gachaConfig - ガチャ設定
         * @param {number[]} seeds - 全シード値の配列
         * @param {object} lastDrawInfo - 直前のドロー情報 ({rarity, charId})
         * @returns {object} - ロール結果の詳細
         */
        function rollWithSeedConsumptionFixed(startIndex, gachaConfig, seeds, lastDrawInfo) {
            if (startIndex + 1 >= seeds.length) return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: null, charId: null, s0: null, s1: null, s2: null };
            
            // S0, S1, S2 are seeds[startIndex], seeds[startIndex+1], seeds[startIndex+2]
            const s0_seed = seeds[startIndex];
            const s1_seed = seeds[startIndex + 1];

            // Rarity Roll (based on S0)
            const rarityRoll = s0_seed % 10000;
            const rates = gachaConfig.rarity_rates || {};
            const rareRate = rates.rare || 0, superRate = rates.super || 0, uberRate = rates.uber || 0, legendRate = rates.legend || 0;
            let currentRarity;
            if (rarityRoll < rareRate) { currentRarity = 'rare'; } else if (rarityRoll < rareRate + superRate) { currentRarity = 'super'; } else if (rarityRoll < rareRate + superRate + uberRate) { currentRarity = 'uber'; } else if (rarityRoll < rareRate + superRate + uberRate + legendRate) { currentRarity = 'legend'; } else { currentRarity = 'rare'; }
            
            const characterPool = gachaConfig.pool[currentRarity] || [];
            if (characterPool.length === 0) {
                // s2_seedも返すように修正 (誘発ロジックが参照するため)
                const s2_seed = (startIndex + 2 < seeds.length) ? seeds[startIndex + 2] : null;
                return { seedsConsumed: 2, finalChar: { name: "該当なし", id: null }, originalChar: null, isRerolled: false, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, s0: s0_seed, s1: s1_seed, s2: s2_seed };
            }
            
            // Character Roll (based on S1)
            const totalChars = characterPool.length;
            const charIndex = s1_seed % totalChars;
            let character = characterPool[charIndex];
            const originalChar = character;
            let seedsConsumed = 2;
            let isRerolled = false;
            let s2_seed = (startIndex + 2 < seeds.length) ? seeds[startIndex + 2] : null; // s2は常に読み込む
            let reRollIndex = null;
            let uniqueTotal = null;

            if (currentRarity === 'rare' && lastDrawInfo && lastDrawInfo.rarity === 'rare' && lastDrawInfo.charId === character.id) {
                // Rare Dupe Check
                const uniqueRareChars = characterPool.filter(c => c.id !== lastDrawInfo.charId);
                uniqueTotal = uniqueRareChars.length;
                
                if (uniqueTotal > 0) {
                    // Reroll is possible (3 seeds consumed)
                    if (s2_seed === null) { // s2 がない場合はデータ不足
                         return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: null, charId: null, s0: s0_seed, s1: s1_seed, s2: null };
                    }
                    
                    reRollIndex = s2_seed % uniqueTotal;
                    character = uniqueRareChars[reRollIndex];
                    isRerolled = true;
                    seedsConsumed = 3;
                } 
                // If uniqueTotal == 0, seedsConsumed remains 2, isRerolled remains false (unavoidable dupe).
            }
            
            return { 
                s0: s0_seed, s1: s1_seed, s2: s2_seed, 
                originalChar: originalChar, 
                finalChar: character, 
                isRerolled: isRerolled, 
                rarity: currentRarity, 
                charId: character.id, 
                charIndex: charIndex, 
                totalChars: totalChars, 
                uniqueTotal: uniqueTotal,
                reRollIndex: reRollIndex,
                seedsConsumed: seedsConsumed 
            };
        }

        function rollGuaranteedUber(startIndex, gachaConfig, seeds) {
            if (startIndex >= seeds.length) return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: 'uber', charId: null, s0: null };

            const s0_seed = seeds[startIndex];
            const currentRarity = 'uber';
            const characterPool = gachaConfig.pool[currentRarity] || [];
            const totalChars = characterPool.length;
            if (totalChars === 0) {
                return { seedsConsumed: 1, finalChar: { name: "該当なし", id: null }, originalChar: null, isRerolled: false, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, s0: s0_seed };
            }
            const charIndex = s0_seed % totalChars;
            const character = characterPool[charIndex];
            return { seedsConsumed: 1, finalChar: character, originalChar: character, isRerolled: false, rarity: currentRarity, charId: character.id, charIndex: charIndex, totalChars: totalChars, s0: s0_seed };
        }


        function calculateGuaranteedLookahead(startSeedIndex, gachaConfig, allSeeds, initialLastDraw) {
            if (!gachaConfig || !gachaConfig.pool['uber']) return { name: "N/A", nextSeed: null, nextRollStartSeedIndex: null };

            let seedCursor = startSeedIndex;
            let lastDraw = initialLastDraw;
            let nextSimSeedValue = null;

            for (let i = 0; i < 10; i++) {
                if (seedCursor + 1 >= allSeeds.length) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };

                const rollResult = rollWithSeedConsumptionFixed(seedCursor, gachaConfig, allSeeds, lastDraw);
                if (rollResult.seedsConsumed === 0) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };
                
                seedCursor += rollResult.seedsConsumed;
                lastDraw = { rarity: rollResult.rarity, charId: rollResult.charId };
            }

            if (seedCursor >= allSeeds.length) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };
            
            // Guaranteed roll (11th roll is 1-seed roll)
            const guaranteedRollResult = rollGuaranteedUber(seedCursor, gachaConfig, allSeeds);
            if (guaranteedRollResult.seedsConsumed === 0) return { name: "データ不足", nextSeed: null, nextRollStartSeedIndex: null };
            
            seedCursor += guaranteedRollResult.seedsConsumed;
            
            nextSimSeedValue = (seedCursor < allSeeds.length) ? allSeeds[seedCursor] : null;

            return { name: guaranteedRollResult.finalChar.name, nextSeed: nextSimSeedValue, nextRollStartSeedIndex: seedCursor };
        }

        function toggleGuaranteedColumn(index) {
            const idWithG = tableGachaIds[index];
            if (idWithG.endsWith('g')) {
                tableGachaIds[index] = idWithG.slice(0, -1);
            } else {
                tableGachaIds[index] = idWithG + 'g';
            }
            generateRollsTable();
        }

        // --- sim-config ヘルパー関数 ---
        function parseSimConfig(configStr) {
            if (!configStr) return []; // ★ null や '' の場合、空配列を返す
            const configs = [];
            const parts = configStr.split('-');
            for (let i = 0; i < parts.length; i += 2) {
                const id = parts[i];
                const rollStr = parts[i+1];
                if (id && rollStr) {
                    const isGuaranteed = rollStr.endsWith('g');
                    const rolls = parseInt(rollStr.replace('g', ''), 10);
                    configs.push({ id, rolls, g: isGuaranteed });
                }
            }
            return configs;
        }

        function stringifySimConfig(configArr) {
            return configArr.map(c => `${c.id}-${c.rolls}${c.g ? 'g' : ''}`).join('-');
        }
        
        /**
         * 最後のロール数を+1するか、11gの場合は次のセグメントを追加する (継続リンク用)
         * @param {string} configStr - sim-config文字列
         * @returns {string|null} - 更新されたsim-config文字列
         */
        function incrementLastRoll(configStr) {
            if (!configStr) return null;
            const configs = parseSimConfig(configStr);
            if (configs.length > 0) {
                const last = configs[configs.length - 1];
                if (!last.g) { 
                    last.rolls += 1;
                } else {
                    // 11gの次は1
                    configs.push({ id: last.id, rolls: 1, g: false });
                }
            }
            return stringifySimConfig(configs);
        }

        /**
         * 最後のロール数を-1するか、ロール数が1の場合は最後のセグメントを削除する (Rule B: 逆算用)
         * @param {string} configStr - sim-config文字列
         * @returns {string|null} - 更新されたsim-config文字列
         */
        function decrementLastRollOrRemoveSegment(configStr) {
            if (!configStr) return null;
            const configs = parseSimConfig(configStr);
            if (configs.length === 0) return null;

            const last = configs.pop();

            if (last.g) {
                // 確定枠からの逆算の場合 (Rule Aの逆算時)
                if (last.rolls === 11) {
                    last.rolls = 10;
                    last.g = false;
                    configs.push(last);
                }
            } else {
                // 通常抽選からの逆算の場合
                if (last.rolls > 1) {
                    last.rolls -= 1;
                    configs.push(last);
                }
                // last.rolls === 1 の場合、セグメントは削除
            }

            return configs.length > 0 ? stringifySimConfig(configs) : '';
        }

        /**
         * 確定枠のリンクを生成するロジック（隣接セルからの生成） (Rule E/確定枠のリンク設定)
         * @param {string} configStr - 左のセル (通常抽選) のsim-config
         * @param {string} gachaId - 確定枠のガチャID
         * @returns {string|null} - 生成された確定枠のsim-config、またはnull
         */
        function generateGuaranteedConfig(configStr, gachaId) {
            if (!configStr) return null;

            const parsed = parseSimConfig(configStr);
            if (parsed.length === 0) return null;
            
            // リンクは左のセルのパラメータを参照し、最後のロール数を-1して...
            const lastPart = parsed.pop();
            
            // 最後のセグメントが通常ロールであり、かつロール数が1以上であること
            if (!lastPart.g && lastPart.rolls > 0) { 
                
                // 通常抽選のロール数を -1 する
                const newRollsForLastPart = Math.max(0, lastPart.rolls - 1);
                
                // 置き換える部分 (10ロール分) のシミュレーション設定を再追加
                if (newRollsForLastPart > 0) {
                    lastPart.rolls = newRollsForLastPart;
                    parsed.push(lastPart);
                }

                // 続けて当該列のガチャID、11ｇとする
                parsed.push({ id: gachaId, rolls: 11, g: true });
                
                return stringifySimConfig(parsed);
            }
            return null;
        }

        // --- ★ 5. (新規) 回避/誘発ロジック用ヘルパー関数 ---

        /**
         * i行目のトラックの「代表」リンクを取得する (i-1 や i-2 からの参照用)
         * @param {Map} cellSimConfigs - デフォルトリンクのMap
         * @param {string} track - 'A' or 'B'
         * @param {number} i - 行インデックス
         * @param {Array} gachaConfigs - ガチャ設定配列
         * @returns {string|null} - 見つかった最初のsim-config文字列、またはnull
         */
        function getBestLink(cellSimConfigs, track, i, gachaConfigs) {
            if (i < 0) return null;
            for (const config of gachaConfigs) {
                const configStr = cellSimConfigs.get(`${track}-${i}-${config.id}`);
                if (configStr) {
                    return configStr;
                }
            }
            return null;
        }

        /**
         * 誘発ロジック用に、強制的に3シード消費した場合のキャラ名を取得する
         * @param {object} currentRoll - tableData[i][track][gachaIndex].roll の中身
         * @param {object} gachaConfig - ガチャ設定
         * @returns {string|null} - 再抽選後のキャラ名、またはnull
         */
        function getForcedRerollName(currentRoll, gachaConfig) {
            if (!currentRoll || !gachaConfig || currentRoll.rarity !== 'rare' || currentRoll.s2 === null) {
                return null;
            }
            
            const characterPool = gachaConfig.pool['rare'] || [];
            const uniqueRareChars = characterPool.filter(c => c.id !== currentRoll.originalChar.id);
            const uniqueTotal = uniqueRareChars.length;
            
            if (uniqueTotal > 0) {
                const reRollIndex = currentRoll.s2 % uniqueTotal;
                return uniqueRareChars[reRollIndex].name;
            }
            return null;
        }


        /**
         * (メインロジック) レア被り回避と誘発の代替リンクを計算する
         * @param {string} track - 'A' or 'B'
         * @param {number} i - 行インデックス
         * @param {string} currentGachaId - 現在のガチャID
         * @param {Array} tableData - 全テーブルデータ
         * @param {Array} gachaConfigs - ガチャ設定配列
         * @param {Map} cellSimConfigs - デフォルトリンクのMap
         * @param {number} newRow1Index - CONTINUEエリアの開始行
         * @returns {object} - { link: string|null, rerollCharName: string|null }
         */
        function checkAvoidanceAndForcing(track, i, currentGachaId, tableData, gachaConfigs, cellSimConfigs, newRow1Index) {
            // FIXEDエリア (ハイライト) では実行しない
            if (i < newRow1Index) {
                return { link: null, rerollCharName: null };
            }

            const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
            if (gachaIndex === -1 || !tableData[i] || !tableData[i][track][gachaIndex]) {
                return { link: null, rerollCharName: null };
            }

            const currentRoll = tableData[i][track][gachaIndex].roll;
            const isRerolled = currentRoll.isRerolled; // ガチャX単体での判定
            const originalCharId = currentRoll.originalChar?.id; // originalCharがnullの場合がある
            const originalRarity = currentRoll.rarity;

            // レア以外は対象外
            if (originalRarity !== 'rare' || !originalCharId) {
                return { link: null, rerollCharName: null };
            }

            for (const otherConfig of gachaConfigs) {
                const otherGachaId = otherConfig.id;
                if (otherGachaId === currentGachaId) continue; // 自分自身とは比較しない

                const otherIndex = gachaConfigs.findIndex(c => c.id === otherGachaId);
                const otherRoll_i = tableData[i][track][otherIndex].roll;
                const otherRoll_prev = (i > 0) ? tableData[i-1][track][otherIndex].roll : null;

                if (isRerolled) {
                    // --- 1. レア被り回避 (Avoid Dupe) ---
                    // (デフォルトが3-seedなので、2-seedになる代替リンク (avoidConfig) を探す)

                    // A. 直前の行(i-1)に違うキャラ(Y)がいる
                    if (otherRoll_prev && otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId !== originalCharId) {
                        // [config_i-2] + [Y-1] + [X-1]
                        // 注: 3シード消費 (A->B または B->A) をまたいだ i-2 の参照は複雑すぎるため、
                        // i-1 が2シード消費だった場合の i-2 (同一トラック) のみ考慮する。
                        const prevRoll = (i > 0) ? tableData[i-1][track][gachaIndex].roll : null;
                        if (prevRoll && prevRoll.seedsConsumed <= 2) {
                             const prevPrevConfig = getBestLink(cellSimConfigs, track, i - 2, gachaConfigs);
                             if (prevPrevConfig !== null) {
                                return { link: stringifySimConfig([...parseSimConfig(prevPrevConfig), {id: otherGachaId, rolls: 1, g: false}, {id: currentGachaId, rolls: 1, g: false}]), rerollCharName: null };
                             }
                        }
                    }
                    // B. 当該行(i)に違うキャラ(Y)がいる
                    if (otherRoll_i && otherRoll_i.rarity === 'rare' && otherRoll_i.charId !== originalCharId) {
                        // [config_i-1] + [Y-1]
                        const prevConfig = getBestLink(cellSimConfigs, track, i - 1, gachaConfigs);
                         if (prevConfig !== null) {
                            return { link: stringifySimConfig([...parseSimConfig(prevConfig), {id: otherGachaId, rolls: 1, g: false}]), rerollCharName: null };
                         }
                    }
                } else {
                    // --- 2. レア被り誘発 (Force Dupe) ---
                    // (デフォルトが2-seedなので、3-seedになる代替リンク (forceConfig) を探す)
                    
                    // A. 直前の行(i-1)に同じキャラ(Y)がいる
                    if (otherRoll_prev && otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId === originalCharId) {
                        // [config_i-2] + [Y-1] + [X-1]
                        const prevRoll = (i > 0) ? tableData[i-1][track][gachaIndex].roll : null;
                        if (prevRoll && prevRoll.seedsConsumed <= 2) {
                            const prevPrevConfig = getBestLink(cellSimConfigs, track, i - 2, gachaConfigs);
                            if (prevPrevConfig !== null) {
                                const rerollCharName = getForcedRerollName(currentRoll, gachaConfigs[gachaIndex]);
                                return { link: stringifySimConfig([...parseSimConfig(prevPrevConfig), {id: otherGachaId, rolls: 1, g: false}, {id: currentGachaId, rolls: 1, g: false}]), rerollCharName: rerollCharName };
                            }
                        }
                    }
                    // B. 当該行(i)に直前(X, i-1)と同じキャラ(Y)がいる
                    const prevRoll = (i > 0) ? tableData[i-1][track][gachaIndex].roll : null;
                    if (prevRoll && prevRoll.rarity === 'rare' && otherRoll_i && otherRoll_i.rarity === 'rare' && otherRoll_i.charId === prevRoll.charId) {
                         // [config_i-1] + [Y-1]
                        const prevConfig = getBestLink(cellSimConfigs, track, i - 1, gachaConfigs);
                        if (prevConfig !== null) {
                            const rerollCharName = getForcedRerollName(currentRoll, gachaConfigs[gachaIndex]);
                            return { link: stringifySimConfig([...parseSimConfig(prevConfig), {id: otherGachaId, rolls: 1, g: false}]), rerollCharName: rerollCharName };
                        }
                    }
                }
            }

            return { link: null, rerollCharName: null };
        }

        // --- ヘルパー関数 終了 ---


        function generateRollsTable() {
            try {
                if (Object.keys(gachaMasterData).length === 0) { return; }
                const initialSeed = parseInt(document.getElementById('seed').value, 10);
                const numRolls = currentRolls;
                if (isNaN(initialSeed) || isNaN(numRolls)) {
                    document.getElementById('rolls-table-container').innerHTML = '<p class="error">エラー: 有効な値を入力してください。</p>';
                    return;
                }
                
                // 3. シード値配列の定義と初期化
                const seeds = [];
                const rngForSeeds = new Xorshift32(initialSeed);
                // 最大のロール回数 * 3 + 20シード分を確保
                for (let i = 0; i < numRolls * 3 + 20; i++) { seeds.push(rngForSeeds.next()); }

                // 1. sim-config の処理
                const simConfigInput = document.getElementById('sim-config').value.trim();
                let simConfigs = [];
                
                if (simConfigInput) {
                    simConfigs = parseSimConfig(simConfigInput);
                    simConfigs.forEach(sim => {
                        // ガチャマスターから設定を読み込む
                        if (gachaMasterData.gachas[sim.id]) {
                            sim.gachaConfig = gachaMasterData.gachas[sim.id];
                        }

                        const gachaIdInTable = sim.g ? `${sim.id}g` : sim.id;
                        const hasGuaranteed = tableGachaIds.includes(`${sim.id}g`);

                        if (!tableGachaIds.includes(gachaIdInTable)) {
                            if (sim.g) {
                                tableGachaIds.push(gachaIdInTable);
                            } else {
                                if (!hasGuaranteed) {
                                    tableGachaIds.push(gachaIdInTable);
                                }
                            }
                        }
                    });
                }
                
                const uniqueGachaIds = [...new Set(tableGachaIds.map(id => id.replace('g', '')))];
                const gachaConfigs = uniqueGachaIds.map(id => gachaMasterData.gachas[id]).filter(Boolean);


                // 2. シミュレーション実行 (ハイライトと計算過程のため)
                const highlightMap = new Map(); // key 'row-track' or 'row-trackG' -> 'gachaId'
                const simulationResults = [];
                
                let rngForText = new Xorshift32(initialSeed);
                let currentSeedIndex = 0;
                let lastDrawForHighlight = { rarity: null, charId: null };
                let pathDetails = []; // ハイライトされた通常抽選セルの {row, track, id} を格納
                let totalSimRolls = 0;

                if (simConfigs.length > 0) {
                    for (const sim of simConfigs) {
                        if (!sim.gachaConfig) continue; 

                        const isGuaranteedPath = sim.g && sim.rolls === 11;
                        
                        // 確定枠を含む11連
                        if (isGuaranteedPath) {
                            const startTrack = (currentSeedIndex % 2 === 0) ? 'A' : 'B'; 
                            const startRow = Math.floor(currentSeedIndex / 2);

                            for (let i = 0; i < 10; i++) {
                                const row = Math.floor(currentSeedIndex / 2);
                                const track = (currentSeedIndex % 2 === 0) ? 'A' : 'B';
                                if (row >= numRolls) break;
                                
                                highlightMap.set(`${row}-${track}`, sim.id);
                                
                                const rollResult = rollWithSeedConsumptionFixed(currentSeedIndex, sim.gachaConfig, seeds, lastDrawForHighlight);
                                if (rollResult.seedsConsumed === 0) break;
                                
                                pathDetails.push({ row, track, id: sim.id });
                                
                                lastDrawForHighlight = { rarity: rollResult.rarity, charId: rollResult.charId };
                                currentSeedIndex += rollResult.seedsConsumed;

                                for(let k = 0; k < rollResult.seedsConsumed; k++) rngForText.next(); 
                                simulationResults.push({ ...sim, result: rollResult, track: track, isGuaranteed: false, rollNum: ++totalSimRolls });
                            }
                            
                            // 11回目（確定）
                            if (startRow < numRolls) {
                                highlightMap.set(`${startRow}-${startTrack}G`, sim.id); 
                            }

                            if (currentSeedIndex >= seeds.length) continue;
                            const guaranteedResult = rollGuaranteedUber(currentSeedIndex, sim.gachaConfig, seeds);
                            
                            currentSeedIndex += guaranteedResult.seedsConsumed;
                            for(let k = 0; k < guaranteedResult.seedsConsumed; k++) rngForText.next(); 

                            simulationResults.push({ ...sim, result: guaranteedResult, track: startTrack, isGuaranteed: true, rollNum: ++totalSimRolls });
                            
                        } else {
                            // 通常ロール
                            for (let i = 0; i < sim.rolls; i++) {
                                const row = Math.floor(currentSeedIndex / 2);
                                const track = (currentSeedIndex % 2 === 0) ? 'A' : 'B';
                                if (row >= numRolls) break;

                                highlightMap.set(`${row}-${track}`, sim.id);

                                const rollResult = rollWithSeedConsumptionFixed(currentSeedIndex, sim.gachaConfig, seeds, lastDrawForHighlight);
                                if (rollResult.seedsConsumed === 0) break;

                                pathDetails.push({ row, track, id: sim.id });

                                lastDrawForHighlight = { rarity: rollResult.rarity, charId: rollResult.charId };
                                currentSeedIndex += rollResult.seedsConsumed;

                                for(let k = 0; k < rollResult.seedsConsumed; k++) rngForText.next(); 
                                simulationResults.push({ ...sim, result: rollResult, track: track, isGuaranteed: false, rollNum: ++totalSimRolls });
                            }
                        }
                    }
                }
                finalSeedForUpdate = rngForText.seed;
                
                // 3. テーブルデータと全ロール結果の準備
                const tableData = Array(numRolls).fill(null).map(() => ({ A: [], B: [] }));
                
                gachaConfigs.forEach((config, gachaIndex) => {
                    if (!config) return;
                    let prevDrawA = { rarity: null, charId: null };
                    let prevDrawB = { rarity: null, charId: null };

                    for (let i = 0; i < numRolls; i++) {
                        // --- Track A ---
                        const rollResultA = rollWithSeedConsumptionFixed(i * 2, config, seeds, prevDrawA);
                        tableData[i].A[gachaIndex] = { gachaId: config.id, roll: rollResultA };
                        prevDrawA = { rarity: rollResultA.rarity, charId: rollResultA.charId };

                        // --- Track B ---
                        const rollResultB = rollWithSeedConsumptionFixed(i * 2 + 1, config, seeds, prevDrawB);
                        tableData[i].B[gachaIndex] = { gachaId: config.id, roll: rollResultB };
                        prevDrawB = { rarity: rollResultB.rarity, charId: rollResultB.charId };
                        
                        if (i * 2 + 3 >= seeds.length) break; 
                    }
                });


                // 4. リンク(sim-config)マップの計算 (ハイライト/非ハイライト統合)
                
                const cellSimConfigs = new Map(); // key 'A-i-id' -> "sim-config-string" (デフォルトリンク)
                // ★ 新規: 代替リンク (回避/誘発) を保存するMap
                const cellSimConfigs_Alt = new Map(); // key 'A-i-id' -> { link: string, rerollCharName: string|null }
                const speciallyContinuedLinks = new Map(); // ★ 新規: 特別ロジックで継続されたリンクを追跡
                
                
                // --- (A) ハイライトの終点（新しい開始点）を特定 ---
                let startSeedIndex = currentSeedIndex; // 'currentSeedIndex' はシミュレーション(2.)で計算済み
                let startRow = Math.floor(startSeedIndex / 2);
                let startTrack = (startSeedIndex % 2 === 0) ? 'A' : 'B';
                let newRow1Index = startRow; 
                let baseConfig = simConfigInput; // sim-config入力値をベースとして使う

                if (simConfigInput === '') {
                    // sim-configが空（ハイライトなし）の場合、0行目Aからスタート
                    newRow1Index = 0;
                    startTrack = 'A';
                }

                // === ローカルヘルパー関数定義 (両方の分岐で利用) ===
                const getCellDataFull = (track, row, gachaId) => {
                    const key = `${track}-${row}-${gachaId}`;
                    const gachaIndex = gachaConfigs.findIndex(c => c.id === gachaId);

                    if (row < 0 || row >= numRolls || gachaIndex === -1 || !tableData[row] || !tableData[row][track][gachaIndex]) {
                        return { config: cellSimConfigs.get(key) || null, roll: null, seedsConsumed: 0 };
                    }
                    
                    const roll = tableData[row][track][gachaIndex].roll;
                    return {
                        config: cellSimConfigs.get(key) || null,
                        roll: roll,
                        seedsConsumed: roll.seedsConsumed,
                    };
                };
                
                const getPrevData = (track, i, gachaId) => getCellDataFull(track, i - 1, gachaId);
                const getPrevPrevCrossTrackData = (crossTrack, i, gachaId) => getCellDataFull(crossTrack, i - 2, gachaId);
                // === ローカルヘルパー関数定義 終了 ===


                // --- (C) ハイライト部分のリンクを逆算ロジックで上書き (FIXEDエリア) ---
                // ★★★ 修正: (B)よりも先に(C)を実行する ★★★
                if (pathDetails.length > 0) {
                    const lastStep = pathDetails[pathDetails.length - 1];
                    
                    // Rule A: 一番下にあるハイライトされた通常抽選セルのリンクを設定
                    let lastHighlightedConfig = simConfigInput;
                    if (simConfigInput.endsWith('g')) {
                        const parsed = parseSimConfig(simConfigInput);
                        const lastPart = parsed.pop();
                        if (lastPart && lastPart.g && lastPart.rolls === 11) {
                            lastPart.rolls = 10;
                            lastPart.g = false;
                            parsed.push(lastPart);
                            lastHighlightedConfig = stringifySimConfig(parsed);
                        }
                    }
                    
                    // 設定 (上書き)
                    cellSimConfigs.set(`${lastStep.track}-${lastStep.row}-${lastStep.id}`, lastHighlightedConfig);
                    
                    // Rule B: 1行ずつ上に遡ってパラメーターを設定 (上書き)
                    for (let i = pathDetails.length - 2; i >= 0; i--) {
                        const currentStep = pathDetails[i];
                        const nextStep = pathDetails[i + 1];

                        const nextConfigStr = cellSimConfigs.get(`${nextStep.track}-${nextStep.row}-${nextStep.id}`);
                        const currentConfigStr = decrementLastRollOrRemoveSegment(nextConfigStr);
                        
                        cellSimConfigs.set(`${currentStep.track}-${currentStep.row}-${currentStep.id}`, currentConfigStr);
                    }
                    
                    // Rule D (仕様書) / Rule C (コードコメント): ハイライトと同じトラックの非主軸セル
                    gachaConfigs.forEach(config => {
                        pathDetails.forEach(step => {
                            // ★ 修正: config.id と step.id (その行の主軸ID) を比較
                            if (config.id === step.id) return; // この行の主軸セルなのでスキップ

                            // if (step.track === primaryTrack) { // ★ 修正: このチェックは不要
                                const i = step.row;
                                const cellKey = `${step.track}-${i}-${config.id}`; // これから設定するセル
                                
                                const primaryCellKey = `${step.track}-${i}-${step.id}`; // FIX
                                
                                const primaryConfigStr = cellSimConfigs.get(primaryCellKey);
                                
                                // ★ 修正: primaryConfigStr が '' (空文字) の場合も考慮
                                if (primaryConfigStr === '' || primaryConfigStr === null || typeof primaryConfigStr === 'undefined') {
                                    // 主軸セルがリンクなし ('' or null) なら、他も null
                                    cellSimConfigs.set(cellKey, null);
                                } else {
                                    // 主軸セルにリンクがある
                                    let newConfig = parseSimConfig(primaryConfigStr);
                                    if (newConfig.length > 0) {
                                        newConfig[newConfig.length - 1].id = config.id;
                                        cellSimConfigs.set(cellKey, stringifySimConfig(newConfig));
                                    } else {
                                        cellSimConfigs.set(cellKey, null);
                                    }
                                }
                            // } // ★ 修正: 閉じカッコ
                        });
                    });
                    
                    // Rule C (仕様書) / Rule D/F (コードコメント): 反対側トラックのセルはリンクなし
                    // ★ 修正: pathDetails に含まれるトラックの種類を確認
                    const tracksInPath = [...new Set(pathDetails.map(step => step.track))];
                    
                    if (tracksInPath.length === 1) {
                        // パスが単一トラックにのみ存在する場合 (トラック移動がなかった場合)
                        const primaryTrack = tracksInPath[0];
                        const oppositeTrack = (primaryTrack === 'A') ? 'B' : 'A';
                        
                        const highlightedRows = [...new Set(pathDetails.map(step => step.row))];

                        highlightedRows.forEach(row => {
                             gachaConfigs.forEach(config => {
                                 cellSimConfigs.set(`${oppositeTrack}-${row}-${config.id}`, null);
                             });
                        });
                    }
                    // ★ tracksInPath.length > 1 の場合 (トラック移動があった場合)、
                    // 両方のトラックにハイライトセルが存在するため、
                    // Rule C (反対側トラックを null にする) は実行しない。
                    // (Rule D が両方のトラックの非主軸セルを正しく設定する)
                }
                // --- (C) FIXEDエリアのリンク設定 終了 ---


                // --- (B) 継続リンクの生成 (CONTINUEエリア) ---
                for (let i = newRow1Index; i < numRolls; i++) {
                    gachaConfigs.forEach(config => {
                        const id = config.id;
                        
                        let configA = null;
                        let configB = null;

                        if (i === newRow1Index) {
                            // --- "新しい1行目" (FIX & Continueの開始点) ---
                            if (startTrack === 'A') {
                                configA = `${baseConfig ? baseConfig + '-' : ''}${id}-1`;
                            } else { // startTrack === 'B'
                                configB = `${baseConfig ? baseConfig + '-' : ''}${id}-1`;
                            }
                        } else {
                            // --- "新しい2行目" 以降 (CONTINUE) ---
                            const prevA = getPrevData('A', i, id);
                            const prevB = getPrevData('B', i, id);
                            const gachaIndex = gachaConfigs.findIndex(c => c.id === id);

                            // --- Default A-i Logic ---
                            const isPrevASpecial = speciallyContinuedLinks.get(`A-${i - 1}-${id}`);
                            if (prevA.config && (prevA.seedsConsumed <= 2 || isPrevASpecial)) {
                                configA = incrementLastRoll(prevA.config);
                            } else {
                                const prevPrevB = getPrevPrevCrossTrackData('B', i, id);
                                if (prevPrevB.config && prevPrevB.seedsConsumed === 3) {
                                    configA = incrementLastRoll(prevPrevB.config);
                                }
                            }

                            // --- Default B-i Logic ---
                            const isPrevBSpecial = speciallyContinuedLinks.get(`B-${i - 1}-${id}`);
                            if (prevB.config && (prevB.seedsConsumed <= 2 || isPrevBSpecial)) {
                                configB = incrementLastRoll(prevB.config);
                            } else {
                                const prevA_for_B = getPrevData('A', i, id);
                                if (prevA_for_B.config && prevA_for_B.seedsConsumed === 3) {
                                    configB = incrementLastRoll(prevA_for_B.config);
                                }
                            }

                            // --- Special Override Logic ---
                            if (gachaIndex !== -1) {
                                const prevRollDataA = tableData[i - 1]?.A[gachaIndex];
                                if (prevRollDataA && prevRollDataA.roll.isRerolled) {
                                    const prevAltDataA = cellSimConfigs_Alt.get(`A-${i - 1}-${id}`);
                                    const prevConfigStrA = cellSimConfigs.get(`A-${i - 1}-${id}`);
                                    if (prevAltDataA && prevAltDataA.link && prevConfigStrA) {
                                        configA = incrementLastRoll(prevAltDataA.link); // OVERRIDE
                                        speciallyContinuedLinks.set(`A-${i}-${id}`, true); // Mark for next iteration
                                    }
                                }
                                const prevRollDataB = tableData[i - 1]?.B[gachaIndex];
                                if (prevRollDataB && prevRollDataB.roll.isRerolled) {
                                    const prevAltDataB = cellSimConfigs_Alt.get(`B-${i - 1}-${id}`);
                                    const prevConfigStrB = cellSimConfigs.get(`B-${i - 1}-${id}`);
                                    if (prevAltDataB && prevAltDataB.link && prevConfigStrB) {
                                        configB = incrementLastRoll(prevAltDataB.link); // OVERRIDE
                                        speciallyContinuedLinks.set(`B-${i}-${id}`, true); // Mark for next iteration
                                    }
                                }
                            }

                            // --- New Cross-Track Logic ---
                            if (gachaIndex !== -1) {
                                // Rule 1: A(i-1) -> B(i)
                                const triggerCellA = tableData[i - 1]?.A[gachaIndex];
                                if (triggerCellA && triggerCellA.roll.isRerolled) {
                                    const triggerAltA = cellSimConfigs_Alt.get(`A-${i - 1}-${id}`);
                                    const triggerDefaultA = cellSimConfigs.get(`A-${i - 1}-${id}`);
                                    if (triggerAltA && triggerAltA.link && triggerDefaultA) {
                                        const sourceCellB_Alt = cellSimConfigs_Alt.get(`B-${i - 1}-${id}`);
                                        if (sourceCellB_Alt && sourceCellB_Alt.link) {
                                            configB = incrementLastRoll(sourceCellB_Alt.link);
                                        }
                                    }
                                }

                                // Rule 2: B(i-2) -> A(i)
                                if (i > 1) {
                                    const triggerCellB = tableData[i - 2]?.B[gachaIndex];
                                    if (triggerCellB && triggerCellB.roll.isRerolled) {
                                        const triggerAltB = cellSimConfigs_Alt.get(`B-${i - 2}-${id}`);
                                        const triggerDefaultB = cellSimConfigs.get(`B-${i - 2}-${id}`);
                                        if (triggerAltB && triggerAltB.link && triggerDefaultB) {
                                            const sourceCellA_Alt = cellSimConfigs_Alt.get(`A-${i - 1}-${id}`);
                                            if (sourceCellA_Alt && sourceCellA_Alt.link) {
                                                configA = incrementLastRoll(sourceCellA_Alt.link);
                                            }
                                        }
                                    }
                                }
                            }
                            // --- End of New Cross-Track Logic ---
                        }

                        cellSimConfigs.set(`A-${i}-${id}`, configA);
                        cellSimConfigs.set(`B-${i}-${id}`, configB);

                        // --- Reroll/Force-reroll (Alternative) Link Calculation ---
                        const altDataA = checkAvoidanceAndForcing('A', i, id, tableData, gachaConfigs, cellSimConfigs, newRow1Index);
                        const altDataB = checkAvoidanceAndForcing('B', i, id, tableData, gachaConfigs, cellSimConfigs, newRow1Index);
                        
                        if (altDataA.link) {
                            cellSimConfigs_Alt.set(`A-${i}-${id}`, altDataA);
                        }
                        if (altDataB.link) {
                            cellSimConfigs_Alt.set(`B-${i}-${id}`, altDataB);
                        }
                    });
                }
                // --- (B) CONTINUEエリアのリンク設定 終了 ---


                // 5. HTMLテーブルの構築
                const buttonHtml = `<button class="add-gacha-btn" onclick="addGachaColumn()">＋列を追加</button>`;
                let totalColsA = 0;
                tableGachaIds.forEach(idWithG => {
                    const id = idWithG.replace('g', '');
                    if (gachaMasterData.gachas[id]) {
                        totalColsA += idWithG.endsWith('g') ? 2 : 1;
                    }
                });
                
                const seedColClass = `seed-column ${showSeedColumns ? '' : 'hidden'}`;

                let tableHtml = `<table><thead>
                    <tr>
                        <th rowspan="2" class="col-no">NO.</th>
                        <th rowspan="2" class="${seedColClass}">SEED 1</th>
                        <th rowspan="2" class="${seedColClass}">SEED 2</th>
                        <th colspan="${totalColsA}">A ${buttonHtml}</th>
                        <th rowspan="2" class="col-no">NO.</th>
                        <th rowspan="2" class="${seedColClass}">SEED 1</th>
                        <th rowspan="2" class="${seedColClass}">SEED 2</th>
                        <th colspan="${totalColsA}">B</th>
                    </tr>
                    <tr>`;
                
                // Headers for Track A and B
                tableGachaIds.forEach((idWithG, index) => {
                    const isGuaranteed = idWithG.endsWith('g');
                    const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                    const gachaConfig = gachaMasterData.gachas[id];
                    if (!gachaConfig) return;

                    const removeButtonHtml = `<button onclick="removeGachaColumn(${index})">x</button>`;
                    const gButtonHtml = `<button onclick="toggleGuaranteedColumn(${index})">G</button>`;
                    let selectorHtml = `<select onchange="updateGachaSelection(this, ${index})">`;
                    Object.keys(gachaMasterData.gachas).forEach(gachaId => {
                        selectorHtml += `<option value="${gachaId}" ${gachaId === id ? 'selected' : ''}>${gachaMasterData.gachas[gachaId].name}</option>`;
                    });
                    selectorHtml += '</select>';
                    const headerName = `${gachaConfig.name} (ID: ${gachaConfig.id})`;

                    if (isGuaranteed) {
                        tableHtml += `<th colspan="2"><div class="gacha-select-header">${selectorHtml}<span>${headerName}</span><br/>${gButtonHtml}${removeButtonHtml}</div></th>`;
                    } else {
                        tableHtml += `<th><div class="gacha-select-header">${selectorHtml}<span>${headerName}</span><br/>${gButtonHtml}${removeButtonHtml}</div></th>`;
                    }
                });

                tableGachaIds.forEach((idWithG, index) => {
                    const isGuaranteed = idWithG.endsWith('g');
                    const id = isGuaranteed ? idWithG.slice(0, -1) : idWithG;
                    const gachaConfig = gachaMasterData.gachas[id];
                    if (!gachaConfig) return;
                    const headerName = `${gachaConfig.name} (ID: ${gachaConfig.id})`;

                    if (isGuaranteed) {
                        tableHtml += `<th colspan="2">${headerName}</th>`;
                    } else {
                        tableHtml += `<th>${headerName}</th>`;
                    }
                });

                tableHtml += `</tr></thead><tbody>`;

                // --- セルコンテンツ生成ロジックのヘルパー関数 ---
                function generateCellContent(track, i, id) {
                    const gachaIndex = gachaConfigs.findIndex(c => c.id === id);
                    if (gachaIndex === -1 || !tableData[i] || !tableData[i][track][gachaIndex] || !tableData[i][track][gachaIndex].roll) return 'N/A';
                    
                    const fullRoll = tableData[i][track][gachaIndex].roll;
                    
                    // ★ デフォルトリンク と 代替リンク を両方取得
                    const configStr = cellSimConfigs.get(`${track}-${i}-${id}`);
                    const altData = cellSimConfigs_Alt.get(`${track}-${i}-${id}`) || { link: null, rerollCharName: null };
                    const altConfigStr = altData.link;
                    
                    const highlightClass = (highlightMap.get(`${i}-${track}`) === id) ? ' highlight' : '';
                    let cellContent = '';
                    
                    // 1. Next Cell Address/Link Calculation
                    let nextAddress = null;
                    
                    // 3シード消費: A(i) -> B(i+1) or B(i) -> A(i+2)
                    if (fullRoll.seedsConsumed === 3) {
                        const destTrack = (track === 'A' ? 'B' : 'A');
                        const destRow = (track === 'A' ? i + 1 : i + 2);
                        // リンクの有無にかかわらず、遷移先番地を計算
                        if (destRow < numRolls) { 
                            nextAddress = `${destRow + 1}${destTrack}`; 
                        }
                    } 
                    // 2シード消費は nextAddress = null (要件に従い非表示)

                    let addressPrefix = nextAddress ? `${nextAddress}) ` : '';
                    
                    // --- ★ 修正: 回避/誘発ロジックを反映 ---
                    
                    if (fullRoll.isRerolled) {
                        // === デフォルト: 3-seed (レア被り) ===
                        const originalCharName = fullRoll.originalChar.name;
                        const rerollCharName = fullRoll.finalChar.name;
                        
                        let originalDisplay = originalCharName;
                        let rerollDisplay = rerollCharName;

                        // 再抽選後 (デフォルトリンク)
                        if (configStr) {
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = '${configStr}'; resetAndGenerateTable();`;
                            rerollDisplay = `<a href="${href}" onclick="${onclickAction}">${addressPrefix}${rerollCharName}</a>`;
                        } else {
                            rerollDisplay = `${addressPrefix}${rerollCharName}`;
                        }
                        
                        // 再抽選前 (回避リンク)
                        if (altConfigStr) {
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(altConfigStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = '${altConfigStr}'; resetAndGenerateTable();`;
                            // 回避(2-seed)はアドレスプレフィックスがつかない
                            originalDisplay = `<a href="${href}" onclick="${onclickAction}">${originalCharName}</a>`;
                        }
                        
                        cellContent = `${originalDisplay}<br>${rerollDisplay}`;
                        
                    } else {
                        // === デフォルト: 2-seed (通常) ===
                        const originalCharName = fullRoll.finalChar.name;
                        let originalDisplay = originalCharName;
                        
                        // 通常キャラ (デフォルトリンク)
                        if (configStr) {
                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = '${configStr}'; resetAndGenerateTable();`;
                            // 2シード消費は nextAddress=null のためアドレスは表示されない
                            originalDisplay = `<a href="${href}" onclick="${onclickAction}">${addressPrefix}${originalCharName}</a>`;
                        } else {
                            originalDisplay = `${addressPrefix}${originalCharName}`;
                        }
                        
                        cellContent = originalDisplay;
                        
                        // 再抽選後 (誘発リンク)
                        if (altConfigStr) {
                            const rerollCharName = altData.rerollCharName || "??";
                            
                            // 誘発(3-seed)はアドレスプレフィックスが *つく*
                            // デフォルトロールは2シードだったが、この代替パスは3シードなので、ここで宛先を計算する必要がある
                            let inducedAddress = null;
                            const destTrack = (track === 'A' ? 'B' : 'A');
                            const destRow = (track === 'A' ? i + 1 : i + 2);
                            if (destRow < numRolls) { 
                                inducedAddress = `${destRow + 1}${destTrack}`; 
                            }
                            const inducedAddressPrefix = inducedAddress ? `${inducedAddress}) ` : '';

                            const href = `?seed=${initialSeed}&sim_config=${encodeURIComponent(altConfigStr)}&gachas=${tableGachaIds.join('-')}`;
                            const onclickAction = `event.preventDefault(); document.getElementById('sim-config').value = '${altConfigStr}'; resetAndGenerateTable();`;
                            
                            const rerollDisplay = `<a href="${href}" onclick="${onclickAction}">${inducedAddressPrefix}${rerollCharName}</a>`;
                            
                            cellContent = `${originalDisplay}<br>${rerollDisplay}`;
                        }
                    }
                    // ---------------------------------

                    return `<td class="gacha-cell${highlightClass}">${cellContent}</td>`;
                }
                
                // --- ヘルパー関数 終了 ---


                for (let i = 0; i < numRolls; i++) {
                    let rowHtml = `<tr><td class="col-no">${i + 1}</td>`;
                    rowHtml += `<td class="${seedColClass}">${seeds[2 * i]}</td><td class="${seedColClass}">${seeds[2 * i + 1]}</td>`;
                    
                    // Track A Cells
                    tableGachaIds.forEach(idWithG => {
                        const isGuaranteedColumn = idWithG.endsWith('g');
                        const id = isGuaranteedColumn ? idWithG.slice(0, -1) : idWithG;
                        const gachaConfig = gachaMasterData.gachas[id];
                        if (!gachaConfig) return; 
                        
                        // Normal A roll
                        rowHtml += generateCellContent('A', i, id);
                        
                        if (isGuaranteedColumn) {
                            // Guaranteed column (G)
                            let lastDraw = (i > 0 && tableData[i-1] && tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)] && tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)].roll) ? { rarity: tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)].roll.rarity, charId: tableData[i-1].A[gachaConfigs.findIndex(c => c.id === id)].roll.charId } : null;
                            const { name: guaranteedChar, nextRollStartSeedIndex } = calculateGuaranteedLookahead(i * 2, gachaConfig, seeds, lastDraw);
                            
                            let guaranteedHighlight = '';
                            let content = guaranteedChar;
                            let nextAddressG = null;

                            // 次のロールの番地を計算
                            if (nextRollStartSeedIndex !== null && nextRollStartSeedIndex < seeds.length) {
                                const nextRow = Math.floor(nextRollStartSeedIndex / 2);
                                const nextTrack = (nextRollStartSeedIndex % 2 === 0) ? 'A' : 'B';
                                nextAddressG = `${nextRow + 1}${nextTrack}`;
                            }

                            // *** 確定枠のハイライト判定 (AトラックのG列) ***
                            if (highlightMap.get(`${i}-AG`) === id) {
                                guaranteedHighlight = ' class="highlight"';
                            }
                            // *************************************************

                            // G列のリンクは、左のセルがリンクの場合に設定 (Rule E)
                            const configStrA = cellSimConfigs.get(`A-${i}-${id}`);
                            const configG_A = generateGuaranteedConfig(configStrA, id); 
                            
                            let addressPrefixG = nextAddressG ? `${nextAddressG}) ` : '';
                            
                            if (configG_A) {
                                const hrefG = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configG_A)}&gachas=${tableGachaIds.join('-')}`;
                                const onclickActionG = `event.preventDefault(); document.getElementById('sim-config').value = '${configG_A}'; resetAndGenerateTable();`;
                                
                                // 要件: 遷移先番地を表示
                                content = `<a href="${hrefG}" onclick="${onclickActionG}">${addressPrefixG}${guaranteedChar}</a>`;
                            } 
                            
                            // リンクがない場合でも、番地は表示する
                            if (!content.includes('<a')) {
                                content = `${addressPrefixG}${guaranteedChar}`;
                            }
                            
                            rowHtml += `<td${guaranteedHighlight}>${content}</td>`;
                        }
                    });

                    rowHtml += `<td class="col-no">${i + 1}</td>`;
                    rowHtml += `<td class="${seedColClass}">${seeds[2 * i + 1]}</td><td class="${seedColClass}">${seeds[2 * i + 2]}</td>`;

                    // Track B Cells
                    tableGachaIds.forEach(idWithG => {
                        const isGuaranteedColumn = idWithG.endsWith('g');
                        const id = isGuaranteedColumn ? idWithG.slice(0, -1) : idWithG;
                        const gachaConfig = gachaMasterData.gachas[id];
                        if (!gachaConfig) return;

                        // Normal B roll
                        rowHtml += generateCellContent('B', i, id);

                        if (isGuaranteedColumn) {
                             // Guaranteed column (G)
                             let lastDraw = (i > 0 && tableData[i-1] && tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)] && tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)].roll) ? { rarity: tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)].roll.rarity, charId: tableData[i-1].B[gachaConfigs.findIndex(c => c.id === id)].roll.charId } : null;
                             const { name: guaranteedChar, nextRollStartSeedIndex } = calculateGuaranteedLookahead(i * 2 + 1, gachaConfig, seeds, lastDraw);
                             
                             let guaranteedHighlight = '';
                             let content = guaranteedChar;
                             let nextAddressG = null;

                             // 次のロールの番地を計算
                             if (nextRollStartSeedIndex !== null && nextRollStartSeedIndex < seeds.length) {
                                const nextRow = Math.floor(nextRollStartSeedIndex / 2);
                                const nextTrack = (nextRollStartSeedIndex % 2 === 0) ? 'A' : 'B';
                                nextAddressG = `${nextRow + 1}${nextTrack}`;
                             }
                             
                             // *** 確定枠のハイライト判定 (BトラックのG列) ***
                             if (highlightMap.get(`${i}-BG`) === id) {
                                guaranteedHighlight = ' class="highlight"';
                             }
                             // *************************************************

                             const configStrB = cellSimConfigs.get(`B-${i}-${id}`);
                             const configG_B = generateGuaranteedConfig(configStrB, id); 

                             let addressPrefixG = nextAddressG ? `${nextAddressG}) ` : '';
                             
                             if (configG_B) {
                                const hrefG = `?seed=${initialSeed}&sim_config=${encodeURIComponent(configG_B)}&gachas=${tableGachaIds.join('-')}`;
                                const onclickActionG = `event.preventDefault(); document.getElementById('sim-config').value = '${configG_B}'; resetAndGenerateTable();`;
                                
                                // 要件: 遷移先番地を表示
                                content = `<a href="${hrefG}" onclick="${onclickActionG}">${addressPrefixG}${guaranteedChar}</a>`;
                             }
                             
                             // リンクがない場合でも、番地は表示する
                             if (!content.includes('<a')) {
                                content = `${addressPrefixG}${guaranteedChar}`;
                             }
                             
                             rowHtml += `<td${guaranteedHighlight}>${content}</td>`;
                        }
                    });
                    
                    rowHtml += `</tr>`;
                    tableHtml += rowHtml;
                }

                tableHtml += '</tbody></table>';
                document.getElementById('rolls-table-container').innerHTML = tableHtml;

                let simulationOutputString = '--- シミュレーション詳細 ---\n';
                if (simulationResults.length > 0) {
                    simulationResults.forEach((sim, index) => {
                        if (!sim || !sim.result) return;
                        const result = sim.result;
                        let line;
                        if (sim.isGuaranteed) {
                             line = `[${sim.rollNum}回目] ${sim.track} | GachaID: ${sim.id} | uber guaranteed ${result.s0} ${result.finalChar.name} (確定枠のシード)`;
                        } else {
                            line = `[${sim.rollNum}回目] ${sim.track} | GachaID: ${sim.id} | ${result.s0}(${result.rarity})${result.rarity}`;
                            if (result.isRerolled) {
                                line += ` ${result.originalChar.name} -> ${result.s2} ${result.finalChar.name} (${result.seedsConsumed} seeds)`;
                            } else {
                                line += `／${result.s1} ${result.finalChar.name} (${result.seedsConsumed} seeds)`;
                            }
                        }
                        simulationOutputString += line + '\n';
                    });
                }
                document.getElementById('result').textContent = simulationOutputString;

                updateUrlParams();
            } catch (e) {
                document.getElementById('rolls-table-container').innerHTML = `<p class="error">テーブルの生成中にエラーが発生しました: ${e.message}</p>`;
                document.getElementById('result').textContent = `エラー: ${e.stack}`; // エラー詳細を表示
                console.error(e);
            }
        }

        window.onload = loadAndProcessData;
    </script>
</body>
</html>